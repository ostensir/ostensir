<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Linux 下搭建 Android 开发环境</title>
      <link href="/2017/12/17/%E6%90%AD%E5%BB%BA%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83-Android/"/>
      <url>/2017/12/17/%E6%90%AD%E5%BB%BA%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83-Android/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>  作者使用命令行进行开发已经习惯了，<br>刚开始Android 开发就遇到了一些问题，<br>网上搜寻很多资料和书籍都是基于 Android Studio的，<br>今天偶然在简书看到了一篇基于命令行构建应用的教程，<br>因此特地写下此教程，并表示感谢下面两篇文章的作者。</p><p><strong>我为什么使用命令行开发</strong><br>其实买本 Android 书（基于 Android Studio）进行学习也是一个不错的选择！<br>比起在命令行中进行软件开发，我更不愿意去学习和研究如何使用一个软件，<br>一来是浪费时间精力去学习使用软件，二来是不熟悉和无法掌握软件的构建过程，<br>另外是能提高开发效率（直接编辑文件+命令编译远比在软件中点来点去要方便多）。<br>但无论如何，从命令中构建程序可使自己更了解项目的目录结构及每个文件所存在的意义。</p><p><strong>插曲</strong><br>此教程仅告诉你如何从下载、安装、配置并直到编译成 apk 文件并测试安装的过程。<br>如果你不太懂下面的一些操作，可以参考我另一篇文章 – [剖析一个项目][0]<br>这篇文章会告诉你那些文件或目录是必须有的，那些是可以改变的，那些是不需要的。</p><p><strong>本文全程参考于以下三个地址：</strong></p><ul><li><a href="https://wiki.archlinux.org/index.php/Android" title="Arch Wiki in Android" target="_blank" rel="noopener">ArchLinux Wiki – Anroid</a>(<a href="https://wiki.archlinux.org/index.php/Android" target="_blank" rel="noopener">https://wiki.archlinux.org/index.php/Android</a>)</li><li><a href="http://www.jianshu.com/p/ba191eb9a23f" target="_blank" rel="noopener">从命令行构建应用-简书</a>(<a href="http://www.jianshu.com/p/ba191eb9a23f" target="_blank" rel="noopener">http://www.jianshu.com/p/ba191eb9a23f</a>)</li><li><a href="http://www.runoob.com/android/android-overview.html" target="_blank" rel="noopener">RUNOOB – Android 教程</a>(<a href="http://www.runoob.com/android/android-overview.html" target="_blank" rel="noopener">http://www.runoob.com/android/android-overview.html</a>)</li></ul><h1 id="本次测试环境各软件版本"><a href="#本次测试环境各软件版本" class="headerlink" title="本次测试环境各软件版本"></a>本次测试环境各软件版本</h1><ul><li>测试系统：Arch Linux 64 bit 4.14.3-1</li><li>JDK 版本：openjdk 7 即：1.7.0_151</li><li>Android platform API 版本：26.8.0.0_r02-1</li><li>Android SDK tool 版本：26.1.1-1</li><li>Android platform tool 版本：r27.0.0-1</li><li>Android Build tool 版本：r27.0.2-1</li><li>本次测试的应用程序 – 简单的 Hello World 程序</li></ul><h1 id="下载和安装-参考于Arch-Wiki"><a href="#下载和安装-参考于Arch-Wiki" class="headerlink" title="下载和安装(参考于Arch Wiki)"></a>下载和安装(参考于<a href="https://wiki.archlinux.org/index.php/Android" title="Arch Wiki in Android" target="_blank" rel="noopener">Arch Wiki</a>)</h1><p><strong>下载 JDK ，之所以下载它是因为它包含一个编译器 javac</strong><br>Arch Packages/Extra: <a href="https://www.archlinux.org/packages/?sort=&amp;q=openjdk7&amp;maintainer=&amp;flagged=" title="Packages" target="_blank" rel="noopener">AUR</a><br>官网: <a href="http://www.oracle.com/technetwork/java/javase/downloads/index.html" title="Oracle java 官网" target="_blank" rel="noopener">Oracle java</a><br><code># pacman -S jdk7-openjdk</code><br><strong>下载 Android SDK 相关工具</strong></p><ol><li>下载 Android SDK 基础工具(包含一些管理 sdk 的命令和设置)<br>Arch: <a href="https://aur.archlinux.org/packages/android-sdk/" title="AUR sdk tool" target="_blank" rel="noopener">Android sdk tool</a><br>官网: <a href="https://dl.google.com/android/repository/sdk-tools-linux-4333796.zip" title="官方 sdk tool" target="_blank" rel="noopener">Android sdk tool</a><br><code># yaourt -S android-sdk</code></li><li>下载 Android 平台相关工具(包含一些和平台相关的工具)<br>Arch: <a href="https://aur.archlinux.org/packages/android-sdk-platform-tools/" title="AUR platform tool" target="_blank" rel="noopener">Android platform tool</a><br>官网: <a href="https://dl.google.com/android/repository/platform-tools_r27.0.0-linux.zip" title="官方 platform tool" target="_blank" rel="noopener">Android platform tool</a><br><code># yaourt -S android-sdk-platform-tools</code></li><li>下载 Android 编译工具（包含和编译软件相关的工具）<br>Arch: <a href="https://aur.archlinux.org/packages/android-sdk-build-tools/" title="AUR Build tool" target="_blank" rel="noopener">Android Build tool 27</a><br>官网: <a href="https://dl-ssl.google.com/android/repository/build-tools_r27.0.2-linux.zip" title="官方 Build tool" target="_blank" rel="noopener">Android Build tool 27</a><br><code># yaourt -S android-sdk-build-tools</code></li><li>下载 Android SDK 平台 API（包含软件要使用的对应平台的 api）<br>参考 Wiki: <a href="https://wiki.archlinux.org/index.php/Android" title="Arch Wiki in Android" target="_blank" rel="noopener">下拉直到标题为 Android SDK Platform APK</a><br>Arch: <a href="https://aur.archlinux.org/packages/android-platform-26/" title="AUR platform 26" target="_blank" rel="noopener">本地测试版本: Android platform 26 </a><br>官网: <a href="https://dl.google.com/android/repository/platform-26_r02.zip" title="官方 platform 26" target="_blank" rel="noopener">Android platform 26</a><br><code># yaourt -S android-platform-26</code></li><li>下载 System 镜像（可选）<br>这是可选的。<br>如果你打算在电脑上运行程序，就需要下载这个镜像。<br>如果你更我一样使用真机进行测试，则忽略这个部分。<br>因为我没有安装过，所以请参考 <a href="https://wiki.archlinux.org/index.php/Android" title="Arch Wiki in Android" target="_blank" rel="noopener">Arch Wiki 官方</a></li></ol><p><strong>提示：</strong></p><ul><li>JDK 有两个版本（openjdk 和 oraclejdk），但我下载的是 openjdk</li><li>貌似 Android API 的版本 和 Build tool 的版本是对应的</li><li>JDK 的版本不能低于Android api 的版本，否则可能无法编译。</li><li>一般情况下，下载最新的 JDK 和最新的 Android SDK 及 Andriod Build tool</li></ul><p><strong>重要声明：</strong></p><ul><li>我初次接触 Android 开发，所以对于各版本匹配不是很明白。</li><li>使用 openjdk 配合以上版本的 Android 26 编译 Hello world 正常。</li><li>我不知道 openjdk 编译其他组件是否正常，因为我才刚开始。</li><li>我不知道以上各版本匹配是否合适于开发各种应用，毕竟 openjdk 是开源的。</li><li>如果有懂这方面的并且不嫌麻烦且乐意的话，<br>还清发一份教程到我邮箱谢谢 xiaocstudio@gmailcom。非常感谢！</li></ul><p><strong>在我的系统上：如果你跟我一样从 AUR 安装，那么</strong><br><em>所有关于Android 的 sdk 及 tool 都安装在 /opt 目录下</em><br><em>java 被安装于 /usr/lib/jvm/ 目录下</em></p><h1 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h1><p>对于 Arch Linux 系统：<br>打开 home 目录下的 .bashrc 文件并添加环境变量。<br>更改之前请先做一个测试，<br>因为对于可以搜寻到软件位置的，则不必再配置。</p><ul><li>测试 java,或显示版本<br><code>$ java -version</code></li><li>测试 Android sdk tools<br><code>$ android</code></li><li>测试 Android platform tools<br><code>$ adb</code></li><li>测试 Android Build tools<br><code>$ aapt</code></li></ul><p>对于提示没有该命令的，则需要添加环境变量到 ~/.bashrc<br>在我的系统中的 ~/.bashrc 如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 尽管我 jdk 版本这样设置但还是 jdk7 我也纳闷！！</span><br><span class="line">export JAVA_HOME=/usr/lib/jvm/java-9-openjdk</span><br><span class="line">export PATH=$JAVA_HOME/jre/bin:$PATH</span><br><span class="line"></span><br><span class="line"># 依次添加 tools 目录，platform-tools 目录，build-tools目录</span><br><span class="line">export ANDROID_HOME=/opt/android-sdk</span><br><span class="line">export PATH=$ANDROID_HOME/tools:$ANDROID_HOME/platform-tools:$ANDROID_HOME/build-tools/:$PATH</span><br></pre></td></tr></table></figure></p><p>提示：确保以上测试命令都可运行。</p><h1 id="构建项目之创建目录结构"><a href="#构建项目之创建目录结构" class="headerlink" title="构建项目之创建目录结构"></a>构建项目之创建目录结构</h1><p><strong>基于 Hello World 程序</strong><br><em><strong>第一阶段</strong></em></p><ol><li>创建项目名字 HelloWorld<br><code>$ mkdir HelloWorld</code></li><li>进入项目根目录创建 AndroidManifest.xml 文件<br><code>$ touch AndroidManifest.xml</code></li><li>我们需要一个源码目录，来保存我们的源代码<br><code>$ mkdir src</code></li><li>我们需要一个资源目录，来保存我们的资源文件<br><code>$ mkdir res</code></li><li>我们需要一个bin目录，来存放编译好的可指向文件<br><code>$ mkdir bin</code></li><li>我们需要一个obj目录，来存放编译期间的中间码文件<br><code>$ mkdiri obj</code></li></ol><p><strong><em>第二阶段</em></strong></p><ol><li>为了编译 java 文件，我们需要在 src/ 创建一个库为 a<br><code>$ mkdir src/a</code></li><li>在库里创建一个包，名为 b<br><code>$ mkdir src/a/b</code></li><li>在包里创建一个类别，名为 c<br><code>$ mkdir src/a/b/c</code></li><li>在类别里创建我们的第一个程序源文件名为 MainActivity.java<br><code>$ touch src/c/b/c/MainActivity.java</code></li></ol><p><strong><em>第三阶段</em></strong></p><ol><li>我们需要在 res/ 下创建一个 drawable 目录来存放程序图标资源名为 logo.png<br><code>$ mkdir res/drawable</code><br>将图片改名为 logo.png 移入 HelloWorld/res/drawable/ 中</li><li>我们还得创建一个 values 目录来存放我们程序所用到的字符串资源<br><code>$ mkdir res/values</code><br><code>$ mkdir res/values/strings.xml</code></li></ol><h1 id="编辑文件，则写代码"><a href="#编辑文件，则写代码" class="headerlink" title="编辑文件，则写代码"></a>编辑文件，则写代码</h1><p><strong>这里不教你如何写代码，直接复制代码测试是否成功编译。</strong></p><ol><li><p>编辑 HelloWorld/AndroidManifest.xml 文件，写入以下内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    package=&quot;a.b.c&quot;</span><br><span class="line">    android:versionCode=&quot;0&quot;</span><br><span class="line">    android:versionName=&quot;1.0&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;uses-sdk</span><br><span class="line">        android:minSdkVersion=&quot;8&quot;</span><br><span class="line">        android:targetSdkVersion=&quot;21&quot; /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;</span><br><span class="line">    &lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; /&gt;</span><br><span class="line">    &lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;application</span><br><span class="line">            android:icon=&quot;@drawable/logo&quot;</span><br><span class="line">            android:label=&quot;@string/app_name&quot;&gt;</span><br><span class="line"></span><br><span class="line">        &lt;activity</span><br><span class="line">            android:name=&quot;a.b.c.MainActivity&quot;</span><br><span class="line">            android:label=&quot;@string/app_name&quot;&gt;</span><br><span class="line">            &lt;intent-filter&gt;</span><br><span class="line">                &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;</span><br><span class="line">                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;</span><br><span class="line">            &lt;/intent-filter&gt;</span><br><span class="line">        &lt;/activity&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/application&gt;</span><br><span class="line"></span><br><span class="line">&lt;/manifest&gt;</span><br></pre></td></tr></table></figure></li><li><p>编辑 HelloWorld/res/values/strings.xml 文件,写入以下内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;resources&gt;</span><br><span class="line">&lt;string name=&quot;app_name&quot;&gt;My Apps&lt;/string&gt;</span><br><span class="line">&lt;string name=&quot;hello_world&quot;&gt;Hello,world!&lt;/string&gt;</span><br><span class="line">&lt;/resources&gt;</span><br></pre></td></tr></table></figure></li><li><p>编辑我们的程序文件，HelloWorld/src/a/b/c/MainActivity.java 写入以下内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package a.b.c;</span><br><span class="line"></span><br><span class="line">import android.app.Activity;</span><br><span class="line">import android.os.Bundle;</span><br><span class="line">import android.widget.TextView;</span><br><span class="line"></span><br><span class="line">public class MainActivity extends Activity</span><br><span class="line">&#123;</span><br><span class="line">@Override</span><br><span class="line">public void onCreate(Bundle savedInstanceState)</span><br><span class="line">&#123;</span><br><span class="line">super.onCreate(savedInstanceState);</span><br><span class="line">TextView textView = new TextView(this);</span><br><span class="line">String helloWorld = getResources().getString(R.string.hello_world);</span><br><span class="line">textView.setText(helloWorld);</span><br><span class="line">setContentView(textView);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="构建项目之编译和生成"><a href="#构建项目之编译和生成" class="headerlink" title="构建项目之编译和生成"></a>构建项目之编译和生成</h1><p><strong>以下命令运行之前要确保你在项目根目录下</strong></p><ul><li>打包资源文件并生成 R 文件<br><code>aapt package -v -f -S res -J ./ -M AndroidManifest.xml -I $ANDROID_HOME/platforms/android-26/android.jar</code><br>此时在根目录下生成一个 R.java 文件，所有资源都打包在里面</li><li><p>编译源文件（.java）生成二进制文件（.class）<br><code>javac -verbose -d obj -classpath $ANDROID_HOME/platforms/android-26/android.jar -sourcepath src src/a/b/c/MainActivity.java ./R.java</code><br>会依次生成以下这些文件位于 obj/ 目录下<br>boj/<br>├── MainActivity.class<br>├── R$attr.class<br>├── R.class<br>├── R$drawable.class<br>└── R$string.class</p></li><li><p>转换所有 .class 文件并生成 dex 可执行文件<br><code>dx --dex --verbose --output=bin/classes.dex obj</code><br>会在 bin 目录下生成 class.dex 文件<br>bin<br>└── classes.dex</p></li><li><p>打包并生成 apk 文件<br><code>aapt package -v -f -M AndroidManifest.xml -S res -I $ANDROID_HOME/platforms/android-26/android.jar -F bin/helloworld.apk bin</code><br>会在 bin 目录下生成未签名的 helloword.apk 文件<br>bin<br>├── classes.dex<br>└── helloworld.apk</p></li><li><p>签名 apk 文件</p></li></ul><ol><li><p>要有签名文件，你肯能没有，我们这里是为了测试所以临时创建一个加密文件<br><code>keytool -v -genkeypair -validity 10000 -dname &quot;CN=company_name,OU=organisational_unit,O=organisation,L=location,S=state,c=country_code&quot; -keystore myapp.keystore -storepass my_keys -keypass key_password -alias key_alias -keyalg RSA</code><br>其中 my_keys 加密密码，后面会验证<br>会在当前目录下创建一个 myapp.keystore 文件</p></li><li><p>签名 apk<br><code>jarsigner -verbose -keystore ./myapp.keystore -keypass key_password -signedjar bin/HelloWorld.apk bin/helloworld.apk key_alias</code><br>会在 bin 目录下生成 HelloWorld.apk<br>bin<br>├── classes.dex<br>├── helloworld.apk 未签名<br>└── HelloWorld.apk 已签名</p></li></ol><h1 id="测试软件"><a href="#测试软件" class="headerlink" title="测试软件"></a>测试软件</h1><p>由于我是在真机测试，所以把 HelloWorld.apk 传到手机安装后即可运行了。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Java语言特性</title>
      <link href="/2017/11/18/Java%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7/"/>
      <url>/2017/11/18/Java%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h1><p>本文所列出的内容仅针对于具有相同基础的人学习，<br>即 C/C++ 中所没有的或者从没遇见过的 Java 语言特性。</p><h2 id="Java-程序结构"><a href="#Java-程序结构" class="headerlink" title="Java 程序结构"></a>Java 程序结构</h2><p><strong>Java 应用程序由 源码文件、机器码文件组成</strong></p><ul><li>源码文件：包含程序的源码，必须以 <code>.java</code> 为扩展名</li><li>机器码文件: 由编译源码文件所生成的二进制文件，其格式为 <code>.class</code> 扩展名</li></ul><p><strong>Java 应用程序由一个，或多个源文件组成</strong></p><ul><li>一个类被保存为一个单独的源文件中</li><li>类名必须与文件名(除去扩展)具有相同名字</li><li>因此 Java 应用程序由一个，或多个类组成</li></ul><h2 id="Java-主程序结构"><a href="#Java-主程序结构" class="headerlink" title="Java 主程序结构"></a>Java 主程序结构</h2><p><strong>Java 应用程序以类进行交互，即一个源码文件就是一个类</strong><br><em>其基本源码形式如下：</em> <code>Test.java 源文件</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Test</span><br><span class="line">&#123;</span><br><span class="line">.....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>主程序中的main函数被作为类的方法存在，且具有特定格式</strong><br><em>其常用源码形式如下:</em> <code>Test.java 源文件</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Test</span><br><span class="line">&#123;</span><br><span class="line">public static void main (String[] args)</span><br><span class="line">&#123;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>声明类的 public 表明此文件以外的文件可访问 Test 类</li><li>声明 main 的 public 表明此类外部可直接访问 main 函数 <code>Test.main(&quot;...&quot;);</code></li><li>声明 main 的 static 表明我们不需要建立 Test 对象也可以直接访问 main 函数</li></ul><p>总结：</p><ul><li>Java 源代码其实就是一个类定义</li><li>Java 主程序中的类里必须包含有 main 方法</li><li>main 方法声明格式必须符合 Java 规定格式</li></ul><h2 id="Java-运行机制"><a href="#Java-运行机制" class="headerlink" title="Java 运行机制"></a>Java 运行机制</h2><ul><li>Java 程序的运行是从 main 函数开始执行</li></ul><p><strong>简明讲解 main 函数：</strong></p><ul><li><p>Java 规定，一个文件保存为一个类，且名字相同<br>因此，java 源代码首先得包含有一个类的声明</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Test</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>通常，我们通过调用一个类的成员函数来执行一个动作<br>因此，我们要使用 main 函数，就必须作为 Test 类成员的形式存在</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Test</span><br><span class="line">&#123;</span><br><span class="line">void main (String[] args)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>类只是一种类型，我们必须建立一个对象才能进行一系列操作。<br>默认情况下类的成员是限制外部访问的形式存在 —- private 权限<br>为使类外部可直接访问类内部成员则必须设定成员为公共访问 —- public 权限</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Test</span><br><span class="line">&#123;</span><br><span class="line">public void main (String[] args)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line"> *建立对象：Test Ts;</span><br><span class="line"> *访问成员：Ts.main (&quot;...&quot;);</span><br><span class="line"> *你可能觉得一起很正常，其实不然</span><br><span class="line"> */</span><br></pre></td></tr></table></figure></li><li><p>main 被作为类的成员，<br>但程序从 main 开始执行，要执行 main 就必须建立对象<br>因此程序在运行的时候并没有办法建立一个 Test 类的对象。<br>为了使 main 能被调用，把 main 函数设定为 static 静态成员。<br>这样无论对象是否存在，都可以通过 <code>Test.main(&quot;...&quot;)</code> 执行第一个语句。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Test</span><br><span class="line">&#123;</span><br><span class="line">public static void main (String[] args)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>关于 <code>public class Test</code> 中 的 <code>public</code> 将在包中讲解</p></li></ul><h2 id="Java-类库结构"><a href="#Java-类库结构" class="headerlink" title="Java 类库结构"></a>Java 类库结构</h2><ul><li>类库指一个库里包含各种各样的类以提供程序使用。</li><li>类库实际上是以目录结构的形式来分布存储的</li></ul><p><strong>以标准库进行讲解：</strong></p><ul><li>JKD 默认安装有一个库名为 java 是一个目录</li><li>java 库里包含有多个包其实际上也是一个目录</li><li>包名是根据类的用途进行分类而命名，如 lang 包、io 包 …</li><li>包里的文件则是我们平常要使用的各个类。</li><li>一个类表现为一个文件然后集合在一个包目录中。</li></ul><p><strong>提示：</strong> <em>java 是 JDK 的基础库，javax 是扩展库</em></p><p>例子：<code>import java.lang.Integer</code><br><em>该语句表明我们引入 <code>java</code> 库里的 <code>lang</code> 包里的 <code>Integer</code> 类为程序使用</em><br><em>该类位于 unix 类系统于：java/lang/Integer</em><br><em>该类位于 Win 类系统于：java\lang\Integer</em></p><p><strong>标准类库表：</strong><br><code>java.lang:</code> <em>用于处理数组及字符串的类，该包在程序中自动被加载</em><br><code>java.io:</code> <em>用于流的输入输出</em><br><code>java.nio.file:</code> <em>用于文件的输入输出</em><br><code>java.util:</code> <em>用于管理数据项</em><br><code>javax.swing:</code> <em>提供灵活易用的组件用于构建图像，GUI 类</em><br><code>java.awt:</code> <em>提供原始的 GUI 组件以及对 swing 组件的一些基本支持</em><br><code>java.awt.geom:</code><em>二维图形</em><br><code>java.awt.event:</code><em>用于 GUI 界面中处理事件</em></p><h2 id="使用类库中的类："><a href="#使用类库中的类：" class="headerlink" title="使用类库中的类："></a>使用类库中的类：</h2><p><strong>方法一：</strong><br><strong>方法二：</strong></p><ul><li>待更新<h2 id="Java-数据类型"><a href="#Java-数据类型" class="headerlink" title="Java 数据类型"></a>Java 数据类型</h2></li><li>基本数据类型：<br><strong>byte 类型:</strong> 字节型，占用 1 字节，8  bit<br><strong>char 类型:</strong> 字符型，占用 2 字节，16 bit</li><li>常量以 <strong>final</strong> 修饰：<code>final int a = 20;</code></li><li>字面值常量：</li><li>待更新</li></ul><h2 id="Java-循环控制"><a href="#Java-循环控制" class="headerlink" title="Java 循环控制"></a>Java 循环控制</h2><ul><li>带标签的 break 语句</li><li>带标签的 continue 语句</li><li>待更新</li></ul><h2 id="Java-类"><a href="#Java-类" class="headerlink" title="Java 类"></a>Java 类</h2><ul><li>待更新</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java 系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java 系列 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Git使用详解</title>
      <link href="/2017/10/18/Git/"/>
      <url>/2017/10/18/Git/</url>
      
        <content type="html"><![CDATA[<h2 id="仓库-init-clone-remote"><a href="#仓库-init-clone-remote" class="headerlink" title="仓库 init,clone,remote"></a>仓库 init,clone,remote</h2><ol><li><p><strong>创建仓库 : init</strong><br><strong>2. 初始化一个目录作为本地仓库 :</strong> <em>请在现有的目录下运行 <code>git init</code></em><br><strong>2. 初始化一个本地仓库指定目录 :</strong> <em>请在当前的目录下运行 <code>git init 目录</code></em><br><em>说明:</em><br><em>执行 git init 的结果会在指定的目录下产生一个 .git 子目录。</em><br><em>该子目录会在你以后对本项目的管理和控制期间起到了至关重要的作用。</em><br><em>该子目录保存了一系列重要的数据及信息以便于你可方便的控制本项目。</em><br><em>以后你在本项目下的所有和操作相关的数据信息都会保存在该子目录中。</em><br><em>此操作实际上是在本地开辟一个仓库并以目录的形式存放于本地磁盘中。</em></p></li><li><p><strong>克隆仓库 : clone</strong><br><strong>1. 进入路径再拷贝仓库 :</strong> <em>在现有的目录下运行 <code>git clone 仓库地址</code></em><br><strong>2. 在拷贝时重命名仓库 :</strong> _在当前的目录下运行 <code>git clone 仓库地址 新名字**3. 拷贝时选择一个路径 :** _在当前的目录下运行</code>git clone path/新名字<code>__说明:__该操作将远端/github的一个仓库克隆到本地并以项目名创建一个同名目录。__如果没有指定仓库名和要保存路径则会在当前的目录下创建一个同名的仓库。__克隆仓库之前它调用 init 对该目录进行初始化，使之包含有 .git 子目录。__在初始化完本地仓库后则把当前项目状态信息拷贝下来保存到 .git 目录中。__在这之后会把其他与项目相关的所有文件拷贝到当前已经初始化过的目录中。__只要没有任何其他意外的话其克隆下来的仓库内容会和远端保持一致的结构。__</code>git clone<code>支持很多种协议:__HTTPS协议:</code><a href="https://github.com/username/repo.git`" target="_blank" rel="noopener">https://github.com/username/repo.git`</a>_<br><em>HTTP协议:   <code>http://github.com/username/repo.git</code></em><br><em>GIT 协议:    <code>git://github.com/username/repo.git</code></em><br><em>FTP 协议:    <code>ftp://github.com/username/repo.git</code></em><br><em>SSH 协议:    <code>ssh://github.com/username/repo.git</code></em><br><em>SSH 协议:    <a href="mailto:`git@github.com" target="_blank" rel="noopener">`git@github.com</a>:username/repo.git`</em><br><em>关于更多协议详细请参考<a href="http://www.ruanyifeng.com/blog/2014/06/git_remote.html" title="跳转到阮一峰博客" target="_blank" rel="noopener">阮一峰博客</a></em></p></li><li><p><strong>关联仓库 : remote</strong><br><em>1. 显式本地仓库所关联的远端仓库名请在仓库目录下运行 <code>git remote</code></em><br><em>2. 显式本地仓库所关联的远端仓库名及地址请在仓库目录下运行 <code>git remote -v</code></em><br><em>3. 为本地仓库创建一个关联到远端仓库请在仓库目录下运行 <code>git add 远端库名 仓库地址</code></em><br><em>4. 删除本地仓库与远端仓库已经被创建的关联请在仓库目录下运行 <code>git rm 远端库名</code></em><br><em>说明:</em><br><em>1. 要关联一个仓库，则你必须要有一个本地仓库参考 1 和 2</em><br><em>2. 要关联一个仓库，远端/github页面上则必须创建一个已存在的仓库</em><br><em>3. git 仓库默认使用 origin 作为远端的仓库名，在 clone 的仓库会有此体现</em><br><em>4. 在创建关联时，远端仓库名可被自定义，其结果就是该名字与仓库地址相关联</em><br><em>5. 在远端/github网页上创建仓库时会给你一个地址，该地址则作为要关联的仓库地址</em><br><em>6. 创建关联的意思就是把本地，与 远端/github页面上的一个仓库进行同步</em><br><em>即关联后，你在仓库的所有操作，都可以通过 git push 更新到远端/github仓库</em></p></li></ol><hr><p><em>注意:</em><br><em>1. 一个已经被初始化的远程仓库，默认使用的远程名为 origin</em><br><em>2. 远端仓库名只是一个标识，可以理解为它是用于标识一个仓库</em><br><em>3. 远端仓库名与你在远端/github页面上创建的仓库名没有任何关系</em><br><em>4. 远端仓库名仅仅代表该名字是后面地址所指向的仓库，详见 git remote -v</em></p><h2 id="跟踪文件-缓存文件-add"><a href="#跟踪文件-缓存文件-add" class="headerlink" title="跟踪文件/缓存文件 add"></a>跟踪文件/缓存文件 add</h2><ol><li><strong>跟踪一个文件的内容 :</strong> <em>在仓库目录下运行 <code>git add 文件名</code></em></li><li><strong>跟踪多个文件的内容 :</strong> <em>在仓库目录下运行 <code>git add 文件1 文件2 ...</code></em></li><li><strong>跟踪所有文件的内容 :</strong> <em>在仓库目录下运行 <code>git add .</code>或<code>./</code>或<code>*</code></em></li><li><strong>跟踪指定类型的文件 :</strong> <em>在仓库目录下运行 <code>git add *.后缀名</code></em></li><li><strong>取消对文件内容跟踪 :</strong> <em>在仓库目录下运行 <code>git reset HEAD 文件名</code></em><br><em>说明 :</em><br><em>1. 跟踪文件也被称为缓存，实际上就是把该文件的当前状态进行保存</em><br><em>2. 该命令以 commit 作为一个开始，即 commit 之后与使用情况1相同</em><br><em>2. 在参考官方的资料中指明 add 命令只缓存文件的内容而不是文件</em><br><em>更多关于 add 的详细内容请参考<a href="https://git-scm.com/book/zh/v2/Git-%E5%9F%BA%E7%A1%80-%E8%AE%B0%E5%BD%95%E6%AF%8F%E6%AC%A1%E6%9B%B4%E6%96%B0%E5%88%B0%E4%BB%93%E5%BA%93" title="gitbook-追踪新文件" target="_blank" rel="noopener">gitbook-追踪新文件</a></em><br><em>使用情况 :</em><br><em>1. 原有的文件没被修改，add 任何文件没有显示</em><br><em>2. 原有的文件已被修改，add 这个文件则会生效</em><br><em>3. 如果创建了一个文件，add 这个文件则会生效</em><br><em>4. 如果删除了一个文件，如果该文件之前不在缓存中，add 这个文件会失败，但不可恢复</em><br><em>5. 如果删除了一个文件，如果该文件之前已在缓存中，add 这个文件没提示，但可以恢复</em><br><em>6. 如果文件已在缓存中，修改该文件后没有add，在缓存中的文件依然是在修改之前的状态</em><br><em>7. 如果你把所有更改的文件都 add 到缓存中后再做一次提交，则 add 任何文件都没有提示</em></li></ol><h2 id="查看项目当前状态-查看缓存情况-status"><a href="#查看项目当前状态-查看缓存情况-status" class="headerlink" title="查看项目当前状态/查看缓存情况 status"></a>查看项目当前状态/查看缓存情况 status</h2><ol><li><strong>详细查看项目的当前状态 :</strong> <em>在仓库目录下运行 <code>git status</code></em></li><li><strong>精简查看项目的当前状态 :</strong> <em>在仓库目录下运行 <code>git status -s</code></em><br><em>说明 :</em><br><em>1. 该命令以一次 commit 为一个开始，即 commdit 之后与情况1相同</em><br><em>使用情况 :</em><br><em>1. 原有的文件没被修改，status 没有任何文件状态</em><br><em>2. 原有的文件已被修改，status 会列出该文件状态</em><br><em>3. 如果曾删了一个文件，status 会列出该文件状态</em><br><em>4. 当把一个文件 add 到缓存，status 则会显式该文件已经被缓存的状态</em><br><em>5. 当把缓存中的文件又修改， status 则会显式该文件的两个版本的状态</em><br><em>6. 当把所有改动的文件都 add 到缓存中时，status 则显示已缓存的文件</em><br><em>7. 如果你现在对所有缓存的文件做 commit，status 则会与情况 1 相同</em><br><em>8. 如果你现在再修改任意一个文件，status 则会列出该文件的当前状态</em><br><em>9. 如果把该文件恢复到原来的样子，status 则显示与情况 1 相同的状态</em></li></ol><hr><p><em>关于 git status -s 的一部分文件状态标识 :</em><br><strong>?? :</strong> <em>表示已修改增加删除而未被跟踪的文件</em><br><strong>A  :</strong> <em>表示正在被跟踪的文件，即已在缓存中的文件</em><br><strong>AM :</strong> <em>M 在右边表示正在跟踪的文件被修改，但未把更改添加到缓存中</em><br><strong>M  :</strong> <em>M 在左边标识正在跟踪的文件被修改，但已把更改添加到缓存中</em><br><em>关于其他更多的标识请参考<a href="https://git-scm.com/book/zh/v2/Git-%E5%9F%BA%E7%A1%80-%E8%AE%B0%E5%BD%95%E6%AF%8F%E6%AC%A1%E6%9B%B4%E6%96%B0%E5%88%B0%E4%BB%93%E5%BA%93" title="gitbook-状态简览" target="_blank" rel="noopener">gitbook-状态简览</a></em></p><h2 id="查看已经提交的或尚未提交的文件更改情况-diff"><a href="#查看已经提交的或尚未提交的文件更改情况-diff" class="headerlink" title="查看已经提交的或尚未提交的文件更改情况 diff"></a>查看已经提交的或尚未提交的文件更改情况 diff</h2><ol><li><strong>查看上次提交之后尚未缓存的所有更改 :</strong> <em>在项目目录下运行 <code>git diff</code></em></li><li><strong>查看上次提交之后已经缓存的所有更改 :</strong> <em>在项目目录下运行 <code>git diff --cached</code></em></li><li><strong>查看已经被缓存和未被缓存的所有更改 :</strong> <em>在项目目录下运行 <code>git diff HEAD</code></em><br><em>说明 :</em><br><em>1. 该命令以一次 commit 为一个开始，即 commit 之后与情况1相同</em><br><em>2. 该命令只对原有的文件起作用，新增加没有 add 过的文件不影响</em><br><em>3. 该该命令显示的是上一次 commit 后到与当前原有文件被更改情况</em><br><em>使用情况 :</em><br><em><strong>diff : 只显示原有的，然后被修改、删除的文件且尚未缓存的</strong></em><br><em>1. 原有的文件没被修改，无论有没 add，diff 则没有任何详细显示</em><br><em>2. 原有的文件已被修改，没有执行 add，diff 会详细显示删减什么</em><br><em>3. 原有的文件已被修改，但执行了 add，diff 则没有任何详细显示</em><br><em>4. 如果删除原有的文件，没有执行 add，diff 会详细显示删减什么</em><br><em>5. 对于刚创建的新文件，无论增删改查，diff 不受任何影响</em><br><em><strong>diff –cached 或 staged : 只显示commit 之后任何被 add 过的文件</strong></em><br><em>1. 原有的文件没被修改，无论有没 add，diff –cached/–staged 则没有任何详细显示</em><br><em>2. 原有的文件已被修改，没有执行 add，diff –cached/–staged 则没有任何详细显示</em><br><em>3. 原有的文件已被修改，但执行了 add，diff –cached/–staged 会详细显示删减什么</em><br><em>4. 如果删除原有的文件，diff –cached/–staged 显示的是在没被删之前的 add 的版本</em><br><em>4. 对于刚创建的新文件，无论增删改查，diff –cached/–staged 不受任何影响</em><br><em><strong>diff HEAD : 则根据以上的情况，同时输出 被 add 和 没 add 的文件</strong></em></li></ol><h2 id="提交更新-commit"><a href="#提交更新-commit" class="headerlink" title="提交更新 commit"></a>提交更新 commit</h2><ol><li><strong>提交缓存内容并且自编辑提交信息 status :</strong> <em>在项目目录下运行 <code>git commit</code></em></li><li><strong>提交缓存内容并且自编辑提交信息 diff   :</strong> <em>在项目目录下运行 <code>git commit -v</code></em></li><li><strong>提交缓存内容的同时编辑提交信息 :</strong> <em>在项目目录下运行 <code>git commit -m &quot;提交信息&quot;</code></em></li><li><strong>先add到缓存后再提交缓存的内容 :</strong> <em>在项目目录下运行 <code>git commit -a</code></em></li><li><strong>撤销对此次从缓存中所提交的内容 :</strong> <em>在项目目录下运行 <code>git commit --amend</code></em></li></ol><h2 id="查看、创建、删除、切换、合并-分支-branch-checkout"><a href="#查看、创建、删除、切换、合并-分支-branch-checkout" class="headerlink" title="查看、创建、删除、切换、合并 分支 branch,checkout"></a>查看、创建、删除、切换、合并 分支 branch,checkout</h2><ol><li><strong>查看所有分支以及所在的分支 :</strong> <em>在项目目录下运行 <code>git branch</code></em></li><li><strong>在主分支下建立一个新的分支 :</strong> <em>在项目目录下运行 <code>git branch 分支名</code></em></li><li><strong>删除一个已有的分支及其数据 :</strong> <em>在项目目录下运行 <code>git branch -d 分支名</code></em></li><li><strong>在所有的分支之间来回的切换 :</strong> <em>在项目目录下运行 <code>git checkout 分支名</code></em></li><li><strong>创建新的分支并切换到该分支 :</strong> <em>在项目目录下运行 <code>git checkout -b 分支名</code></em></li><li><strong>合并另外一个分支到当前分支 :</strong> <em>在项目目录下运行 <code>git merge 分支名</code></em></li></ol><h2 id="移除文件-rm"><a href="#移除文件-rm" class="headerlink" title="移除文件 rm"></a>移除文件 rm</h2><ol><li><strong>移除缓存区与本地的文件 :</strong> <em>在项目目录下运行 <code>git rm 文件名</code></em></li><li><strong>只移除缓存区里面的文件 :</strong> <em>在项目目录下运行 <code>git rm --cached 文件名</code></em></li><li><strong>更方便的性移除多个文件 :</strong> <em>在项目目录下运行 <code>git rm *.后缀名</code></em></li></ol><h2 id="移动文件-更改文件名-mv"><a href="#移动文件-更改文件名-mv" class="headerlink" title="移动文件/更改文件名 mv"></a>移动文件/更改文件名 mv</h2><ol><li><strong>更新一个文件名 :</strong> <em>在项目目录下运行 <code>git mv 源文件 新名字</code></em></li></ol><h2 id="查看提交历史-log"><a href="#查看提交历史-log" class="headerlink" title="查看提交历史 log"></a>查看提交历史 log</h2><ol><li><strong>查看所有的提交历史记录 :</strong> <em>在项目目录下运行 <code>git log</code></em></li><li><strong>精简查看所有的提交历史 :</strong> <em>在项目目录下运行 <code>git log --stat</code></em></li><li><strong>查看提交历史内容的差异 :</strong> <em>在项目目录下运行 <code>git log -p</code></em></li><li><strong>查看最近3 次的提交记录 :</strong> <em>在项目目录下运行 <code>git log -3</code></em></li><li><strong>查看提交历史格式化输出 :</strong> <em>在项目目录下运行 <code>git log --pretty=选项</code></em><br>关于 –pretty=选项</li><li><code>--pretty=oneline</code> <em>每次提交显示为一行</em></li><li><code>--pretty=format:&quot;占位符&quot;</code> <em>定制显示记录的格式</em></li><li><em>一个带占位符的例子 :</em><code>git pretty=format:&quot;%h - %an, %ar : %s&quot;</code><br>关于 format 选项的占位符<br><strong>%H  :</strong> <em>提交对象(commit)的完整哈希字串</em><br><strong>%h  :</strong> <em>提交对象的简短哈希字串</em><br><strong>%T  :</strong> <em>树对象(tree)的完整哈希字串</em><br><strong>%t  :</strong> <em>树对象的简短哈希字串</em><br><strong>%P  :</strong> <em>父对象(parent)的完整哈希字串</em><br><strong>%p  :</strong> <em>父对象的简短哈希字串</em><br><strong>%an :</strong> <em>作者(author)的名字</em><br><strong>%ae :</strong> <em>作者的电子邮件地址</em><br><strong>%ad :</strong> <em>作者修订日期(可以用 –date= 选项定制格式)</em><br><strong>%ar :</strong> <em>作者修订日期,按多久以前的方式显示</em><br><strong>%cn :</strong> <em>提交者(committer)的名字</em><br><strong>%ce :</strong> <em>提交者的电子邮件地址</em><br><strong>%cd :</strong> <em>提交日期</em><br><strong>%cr :</strong> <em>提交日期,按多久以前的方式显示</em><br><strong>%s  :</strong> <em>提交说明</em></li></ol>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>C++ 引用</title>
      <link href="/2017/06/24/%E5%BC%95%E7%94%A8-C++/"/>
      <url>/2017/06/24/%E5%BC%95%E7%94%A8-C++/</url>
      
        <content type="html"><![CDATA[<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ol><li>引用被声明时必须初始化<br><code>int &amp;r;</code> <strong>(错)</strong><br><code>int a; int &amp;r = a</code> <strong>正确</strong></li><li>引用初始化的目标必须是一个对象<br><code>int &amp;r = 2</code> <strong>(错)</strong><br><code>int a; int &amp;r = a</code> <strong>(正确)</strong></li><li>引用的目标不能是一个表达式。<br><code>int &amp;r = 2*4</code> <strong>(错)</strong><br><code>int a; int &amp;r = a</code> <strong>(正确)</strong></li><li>允许引用的目标没初始化<br><code>int a; int &amp;r = a;</code> <strong>正确</strong><br><code>int a = 2; int &amp;r = a;</code> <strong>正确</strong><h2 id="引用和常量"><a href="#引用和常量" class="headerlink" title="引用和常量"></a>引用和常量</h2></li><li>引用所引用的目标必须和自己相同类型<br><code>const int a; int &amp;r = a;</code> <strong>(错)</strong><br><code>const int a; const int &amp;r = a;</code> <strong>(正确)</strong></li><li>声明为常量的引用，允许引用一个非常量的目标<br><code>int a; const int &amp;r = a</code> <strong>(正确)</strong><br> <strong>在这种情况下：</strong><br> 允许修改 a 的值来得到对应修改的 r<br> 但不允许通过 r 来修改 a 的值</li><li>允许声明为常量的引用所引用的对象是一个字面值常量<br><code>int &amp;r  = 2;</code> <strong>(正确)</strong></li><li>允许声明为常量的引用初始值为表达式<br> <strong>第一种情况：</strong><br> <code>int a=2, b=4; const int &amp;r = a*b</code> <strong>(正确)</strong><br> 在这种情况下，在后期修改 a 或 b 的值 ，r 的值永远是 8<br> <strong>第二种情况：</strong><br> <code>const int &amp;r = 2*4</code> <strong>(正确)</strong> <h2 id="引用和指针"><a href="#引用和指针" class="headerlink" title="引用和指针"></a>引用和指针</h2>引用其可以引用任何相同类型的对象，但却不能引用指针，除非把引用声明为指针。<br>当引用的对象是一个指针时，情况就变得有些复杂。</li><li>使用指针来初始化引用<br><code>int a=2; int *p=a; int &amp;r = *p;</code><br> p 指向的是 a ，而 r 引用的也是 a</li><li>引用一个指针对象<br><code>int a; int *p=a; int *&amp;r = p;</code><br> 此时，r 就是指针 p。所有对 p 的操作，对 r 同样适应</li><li>引用本身不允许被再次进行引用，从这个角度看，引用本身也是常量。<br>无论 const int &amp;r =a; 还是 int const &amp;r = a；其作用的是引用的目标是一个常量。<br>而非常量数据类型，给以被转换为常量的数据类型。<h2 id="引用和常量和指针"><a href="#引用和常量和指针" class="headerlink" title="引用和常量和指针"></a>引用和常量和指针</h2>这种情况似乎复杂了很多<br>声明为常量的引用其引用的目标可以是常量也可以是非常量。<br>int a; const int &amp;r = a;    <strong>(引用一个非常量)</strong><br>const int a; const int &amp;r = a; <strong>(引用一个常量)</strong><br>非常量的引用不允许引用一个常量目标<br>const int a; int &amp;r = a; <strong>(这是错误的行为)</strong></li></ol>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>C++指针与常量</title>
      <link href="/2017/06/18/const-C++/"/>
      <url>/2017/06/18/const-C++/</url>
      
        <content type="html"><![CDATA[<h2 id="声明的规范问题"><a href="#声明的规范问题" class="headerlink" title="声明的规范问题"></a>声明的规范问题</h2><p>声明由一个类型名加一个变量名以及一个作为结束的分号构成一条声明语句。<br>根据其声明规范，声明语句左边必须是一个类型名，而右边则是要被声明的变量名字。<br><strong>变量</strong><br><code>int a;</code><br>这是一个规范的声明，左边的类型名(<strong>int</strong>) 决定了 a 是一个 <strong>int</strong> 类型的对象。<br><strong>指针</strong><br><code>int *p;</code><br>这里声明了一个指针，然而，<br>你不能 <code>*int p;</code> (<strong>这是错误的声明方式</strong>)<br>也不能 <code>int p*;</code> (<strong>这是错误的声明方式</strong>)</p><p><strong>总结</strong><br>无论什么情况，类型名都必须在左边，而右边则是要被声明的变量名。</p><h2 id="声明的内存状态"><a href="#声明的内存状态" class="headerlink" title="声明的内存状态"></a>声明的内存状态</h2><p><strong>变量</strong><br><em>假设这样一句声明：</em><code>int a;</code><br>编译器是这么做的，它遇到 int，则分配一块与 int 一样大小的内存。<br>接着遇到 a 时，就把这块内存与 a 这个名字绑定在一起。<br>当你使用 a 时，a 就代表了这块内存。<br><strong>指针</strong><br><em>假设这样一句声明：</em><code>int *p;</code><br>指针，本身用于保存地址，地址只是一串数字。<br>所以对指针的任何类型声明，都对指针自己本身不起任何作用。<br>换句话说，指针前面的类型 int 规定了指针只能保存一块内存的地址，而这块内存必须是 int 类型。<br><strong>例如：</strong><br>在 32 位的机器上，一个地址是 32 位<br>char a = 20;<br>char *p = a;<br>p 保存的是 a 的 32 位地址，而 a 则必须是 char 类型。<br>这里有两块内存，一块是 p 的内存，保存了 a 的地址。<br>另一块内存是 a 的内存空间，保存了 20 这个数据。</p><p>在编译时，p 本身被绑定一块内存，* 号告诉编译器这块内存用于保存另一块内存的地址，<br>而另一块内存则必须是 int 类型。</p><p><strong>举个例子：</strong><br>假设有 <code>桶</code> 这个类型名字。<br>当你使用它来声明一个指针时：<br><code>桶 *p</code><br>这时 p 只能指向一个 <code>桶</code> 却不能指向一张 <code>桌子</code>(假设也有 <code>桌子</code> 这个类型的话)</p><p><strong>总结</strong><br>类型，决定了变量能被存储的范围。<br>指针本身也占用内存，而类型规定了指针只能够指向一块相同类型的内存空间。</p><h2 id="const-的作用"><a href="#const-的作用" class="headerlink" title="const 的作用"></a>const 的作用</h2><p>分清了以上几个概念，这里就很容易理解了。<br>如果说类型是规定了一个变量能够被存储的范围。<br>那么 const 则规定了这个范围内存里的数据是否可被移动(变动)<br><strong>变量</strong><br><code>int const a;</code><br><code>const int a;</code><br>我们指定在编译过程中，编译器把一个类型范围的内存和一个变量名绑定在一起。<br>无论 const 的位置如何变换，类型都是在左边，变量名在右边。<br>所以以上两条语句是一样的，<strong>请看下例：</strong><br><code>桶 const a;</code><br>它是这么告诉编译器的：<br>我要申请一个名字为 a 的内存。<br>这个 a 内存里的数据不可被变动(const)<br>而且，这个不可变动的内存是 <code>桶</code> 类型。<br><code>const 桶 a;</code><br>它是这么告诉编译器的：<br>我要申请一个名字为 a 的内存。<br>这块内存是 <code>桶</code> 类型的。<br>而这个<code>桶</code>类型的内存里的数据不能被改动。</p><p>因此，无论是 <code>const int a;</code> 还是 <code>int const a;</code><br>两者都是相同的，其最终的 a 都是不能被变动的 int 类型内存空间。<br><strong>指针</strong><br><code>const int *p;</code><br><strong>p：</strong>我要申请一个名字为 p 的内存<br><strong>*：</strong>这块内存是要用于保存另一块内存的地址。<br><strong>int：</strong>这另一块内存的大小必须符合 int 大小 (例如 4 字节)<br><strong>const：</strong>这块 4 字节内存里的数据不能被改动<br><code>int const *p;</code><br><strong>p：</strong>我要申请一个名字为 p 的内存<br><strong>*：</strong>这块内存是要用于保存另一块内存的地址。<br><strong>const：</strong>这另一块内存里的数据不能被改动<br><strong>int：</strong>这块不能被改变数据的内存大小必须符合 int 大小 (例如 4 字节)</p><p><strong>因此：</strong><br>p 的类型规定了 p 指向的内存的类型，<br>const 规定了 p 所指向的相同类型的内存空间里的数据不能被改动</p><p><strong>于是：</strong><br><code>int const *p;</code><br><code>const int *p;</code><br>其结果都是指针所指向的的内存空间里的数据不能被改变。<br>这意味着指针本身可以指向(覆盖保存为)另一个相同类型不同数据的内存空间的地址。</p><p><strong>然而：</strong><br><code>int *const p;</code><br><strong>p：</strong>我要申请一个名为 p 的内存。<br><strong>const：</strong>这块内存是不可变动的。<br><strong>*：</strong>这块不可变动的内存是要用于保存另一个内存的地址用的。<br><strong>int：</strong>而这另一个内存地址空间必须为 int 类型。</p><p><strong>于是：</strong><br>p 本身的内存里的数据(所保存的地址) 是不能改变的，<br>而指向的目标内存必须为 int 类型。<br>这意味着可以通过 p 去改变目标内存空间里的数据内容。</p><p><strong>然后：</strong><br>你不能 <code>*int const p;</code>(这是错误的声明方式)<br>也不能 <code>int const p*;</code>(这是错误的声明方式)<br>而 <code>int const *p</code> 和 <code>const int *p</code> (上面已经讲过的)则不同于 <code>int *const p</code> 的意义。<br>因此，<code>int *const p;</code> 只能有一种写法。<br>而这种写法唯一不能改变的是指针本身。</p><p>既然是唯一的，那么下面这两个语句就很容易理解了：<br><code>int const *const p;</code><br><code>const int *const p;</code></p><p>上面讲到了，无论 <code>int const</code> 和 <code>const int</code> 的位置如何变换，其效果都是相同的，<br>都是指定指针所指的内存数据不能改变。<br>而 <code>*const p</code> 只能有一种写法，且其表明指针本身是常量。<br>那么最终结果是指针本身不能改变，所指的内存里的数据也不能改变。<br><strong>请看以下解释：</strong><br><code>int const *const p;</code><br><strong>p：</strong>我想申请一块名为 p 的内存<br><strong>const：</strong>这块内存里的数据不能被改变。<br><strong>*：</strong>这块内存里的数据将要保存的是另一个内存空间的地址。<br><strong>const：</strong>这另一个内存空间里的内容不能被改变。<br><strong>int：</strong>这另一块内存空间的大小必须符合 int 大小。或必须是 int 类型。<br><code>const int *const p;</code><br><strong>p：</strong>我想申请一块名为 p 的内存。<br><strong>const：</strong>这块内存里的数据不能被改变。<br><strong>*：</strong>这块不能被改变的内存空间要保存的是另一个内存空间的地址。<br><strong>int：</strong>这另一块内存空间具有跟 int 一样的大小。<br><strong>const：</strong>这块跟 int 一样大小的内存里的数据不能被修改。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Arch 包管理器</title>
      <link href="/2017/06/09/%E5%8C%85%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6-2-Arch/"/>
      <url>/2017/06/09/%E5%8C%85%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6-2-Arch/</url>
      
        <content type="html"><![CDATA[<p>上一章中，我们对源代码安装软件的过程做了一个总结<br>对 PKGBUILD 文件 和 makepkg 也有了些大概的了解<br>此外，我们还认识了 AUR 、ABS 、和 yaourt 工具。<br>今天让我们来详细了解究竟是如何从源代码安装软件的，<br>以及 PKGBUILD 文件这部分是核心内容，并带你深入的了解 pacman。<br>为了节省时间和字数，以下就不再重复上一章的内容了，直接讲重点内容。</p><h2 id="1-从源代码安装软件"><a href="#1-从源代码安装软件" class="headerlink" title="1. 从源代码安装软件"></a>1. 从源代码安装软件</h2><p>正常情况下，我们下载的源码包会包含以下几个文件：<br>README (读我)<br>INSTALL (安装)<br>COPYING (复件)<br>ChangeLog (更新日志)<br>configure(配置)</p><p><strong>README 文件:</strong><br>是源码包的说明文件，是对整个源码包的一个说明，类似于”安装前读我”。<br>例如: 它会告诉你这是一个什么软件，有哪些功能，能干嘛什么，要安装需要读哪个文件等。<br><strong>INSTALL 文件:</strong><br>它会告诉你要怎样安装这个软件，有时还会如何添加插件或干净的安装的方法。<br>例如: 它可能会告诉你要先执行什么操作再执行哪些操作才能完成安装。<br><strong>COPYING 文件:</strong><br>是包含一些版权信息，例如 GNU许可证，一般都是从官方分发的许可证中复制过来。<br>大致就是告诉你开发者拥有哪些版权，你能否修改源代码，能否重新分发，受到哪些限制等<br><strong>ChangeLog 文件:</strong><br>是告诉你更新了哪些功能，添加了什么新功能，以及一些存在问题并指导你如何处理。</p><p><strong>注意: 在有些软件源码包中，以上这些文件不一定会同时出现。</strong></p><p>另外，<br><strong>Makefile 文件:</strong><br>它只是一个文本文件，其内容包含一些规则，在编译的过程中会读取该文件<br>并安装其中的规则进行编译。其中的内容不过是告诉编译要先编译哪个目录下的文件，<br>再进入哪个目录进行编译，和 要生成哪些名字的文件以及被存放的位置等信息。<br>最后，它有时候还会自动清除编译成功后存在的一些缓存文件。<br><strong>configure 文件:</strong><br>严格来说，它是一个运行脚本(即可被运行的一个文件)，同时它也是一个文本文件。<br>它可以自动设定源程序以符合各种不同平台上 Linux/Unix 系统的特性，<br>并且根据系统参数及环境产生合适的 Makefile 文件或 C 头文件，<br>让源程序可很方便的在这些不同的平台上被编译和链接<br>因此运行这个文件的最终结果会得到以上提到的 Makefile 文件。<br>我们知道，configure 是一个配置文件，但其主要的用途是:<br><strong>1. 根据软件需要，进行软件安装前的一些安装环境配置。</strong><br><strong>2. 配置软件的主要目的为了适应多平台。</strong><br><strong>3. 指引安装后的文件都被存放于系统哪个位置。</strong><br><strong>4. 生成 Makefile 文件以提供编译器编译软件。</strong></p><p><strong>make 工具:</strong><br>这是一个 GNU 工具，它只认识 Makefile 文件(有时候可能并非这个名字，除非在选项中指出)<br>它包含一个命令 <code>make</code>，其命令格式为 <code>make [选项] [文件名]</code><br>这个工具的作用是:<br><strong>除非你用选项指定文件的名字，否则该命令会在当前目录下寻找 Makefile 名字的文件，</strong><br><strong>根据文件的指定的规则，并按规则进行编译整个源码目录。</strong><br><strong>在没有意外的情况下，会成功生成一个最终可执行的文件</strong><br>/<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>/<br><strong>install 工具:</strong><br>顾名思义，就是安装的意思。其实际操作是复制文件到指定的目录并设置属性。<br>这些属性包括例如添加环境变量，设置可执行文件等其他文件的一些权限设置等等。<br>它包含一个命令 <code>install</code> 其命令格式为 <code>install  [选项]  ...</code> 可进行多选项<br>/<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>*</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>/</p><p>有了以上这些知识我们来尝试编译和安装一个软件<br>以 gedit 软件为例，你可到官方[下载][] gedit-3.22.0.tar.xz<br>解压到 home 下得到 gedit-3.22.0 名字的目录，你可先浏览一遍目录，<br>我假设你已经看过 INSTALL 文件(因为不同版本的安装方法可能有所差异)，<br>安装上一章的安装过程: <strong>配置(configure) -&gt; 编译(make) -&gt; 安装(make install)</strong><br>接着执行以下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#cd gedit-3.22.0// 进入源码根目录</span><br><span class="line">#./configure// 运行脚本，进行安装前的系统配置</span><br><span class="line">#make// 编译</span><br><span class="line">#su root// 更改为 root 用户，因为 make install 需要有足够的权限</span><br><span class="line">$make install// 编译并安装</span><br></pre></td></tr></table></figure></p><p>这里主要解释最后三条命令 ，<br>执行 <code>#    ./configure</code>时:<br>它对软件进行配置，并生成最终文件 Makefile 文件。<br>如果这里配置失败，则不会生成 Makefile 文件。<br>执行 <code>#    make</code> 时:<br>它在当前目录下寻找 Makefile 文件，<br>如果上面配置失败则找不到这个文件编译失败<br>如果你略懂 Makefile 的一些规则语法，当你打开这个文件来看就能发现<br>里面有几个几个隐式规则，其中一个就是名为 <code>install</code> 的规则<br>实际上 <code>$    make install</code>就是执行 Makefile 文件中的隐式规则。<br>该规则定义了一系列安装(拷贝)配置等信息。切勿以为是 make 的选项。<br>此外还有几个隐式规则名为: <code>unistall</code>、<code>clean</code>、<code>disclean</code> 等。<br>这意味着你可以卸载，或在安装过程中出现问题可以清除某些缓存文件等。<br>然而在根目录下有一个 install.sh，根据内容说明，好像是当Makefile<br>文件中没有定义 <code>install</code> 隐式规则时，则执行该 bash 脚本进行安装。</p><p>ok！那么在默认情况下，你所安装的软件最终会被分配到这几个目录下:<br><strong>可执行文件在</strong>    <em>/usr/local/bin</em><br><strong>库文件默认在</strong>    <em>/usr/local/lib</em><br><strong>配置文件是在</strong>    <em>/usr/local/etc</em><br><strong>其他资源原件</strong>    <em>/usr/local/share</em></p><p>有时候为了便于集中管理某个软件中的各个文件，<br>或者，为了根据自己的需求来配置软件，便有了配置选项。<br>我们知道，<code># ./configure</code>是运行当前目录下的 configure 配置文件。<br>当你使用选项进行配置的时候是这样 <code># ./configure [选项]=你要设置的东西</code>。<br>配置选项很多，但我不会在这里一一列出来。<br>只是 <code>./configure -help</code>可以查看所有可使用的选项和说明 。<br>于是我只在这里介绍一两个常用的选项。<br><strong>-prefix</strong> 选项<br>该选项用于配置安装后的文件目录分布。<br>如果你在安装前这样配置:<br><code># ./configure -prefix=/usr/</code><br>则软件安装后的所有文件都在 /usr/目录下。<br>这样你就能够很好的管理软件包的各个文件，<br>删除也可直接删除整个软件目录而不残留。</p><p>段落结语:<br>有时候源码安装软件就是这么简单，<br>但有时候还是很麻烦很复杂，<br>甚至还有可能需要手动修改源码才能成功安装。<br>但但部分软件遵循以上散步可以完成安装。<br>[下载]:(<a href="http://ftp.gnome.org/pub/GNOME/sources/gedit/3.22/" target="_blank" rel="noopener">http://ftp.gnome.org/pub/GNOME/sources/gedit/3.22/</a>)</p><h2 id="2-PKGBUILD-文件"><a href="#2-PKGBUILD-文件" class="headerlink" title="2. PKGBUILD 文件"></a>2. PKGBUILD 文件</h2><p>使用 PKGBUILD 的好处是易于修改、可定制(即按自己需求来安装)，<br>从源码下载到成功安装的整个过程都是透明的，使别人无法添加恶意脚本。<br>上一章中我们说到，PKGBUILD 分为三部分，这么说其实不全对，但也不为过。<br>实际上 PKGBUILD 是一个简单的 bash 脚本文件，为文本格式，<br>包含对编译，打包过程的指示，和源代码的下载地址等。<br>该文件的内容其实就是定义一系列变量，和几个函数。<br>变量:<br>理论上(是我个人认为的)，变量名应该可随意改，它被读取的机制应该是按顺序读取。<br>可能是为了让读者容易看，并且格式统一，因此大都采用相同的变量名。<br>我将用这些标准的变量名来讲，以下是标准的 PKGBUILD 个文件的内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// 基本信息</span><br><span class="line">pkgname=软件名</span><br><span class="line">pkgver=软件包版本号</span><br><span class="line">pkgrel=软件版本号</span><br><span class="line">pkgdesc=&quot;软件简介&quot;</span><br><span class="line">arch=(&apos;i686&apos; &apos;x86_64&apos;) // 软件构架，即 32 位还是 64 位</span><br><span class="line">url=&quot;软件下载地址&quot;</span><br><span class="line">license=(&apos;软件包协议，如 GNU 的 GPL 协议&apos;)</span><br><span class="line">depends=(&apos;软件运行的&apos; &apos;依赖&apos;)</span><br><span class="line">optdepends=(&apos;软件的&apos; &apos;可选依赖&apos;)</span><br><span class="line">makedepends=(&apos;软件编译时&apos;  &apos;需要的依赖&apos;)</span><br><span class="line">source=（&quot;编译需要&quot; &quot;的源码&quot;）</span><br><span class="line">md5sums=(&quot;验证源码的完整性&quot;)</span><br><span class="line">// 编译部分，build 是一个函数</span><br><span class="line">build()</span><br><span class="line">&#123;</span><br><span class="line">编译操作</span><br><span class="line">&#125;</span><br><span class="line">// 打包部分，package 是一个函数</span><br><span class="line">package()</span><br><span class="line">&#123;</span><br><span class="line">打包操作</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这两个函数内都是简单的 shell 命令。<br>换句话说，你用源代码是如何编译和打包的的，就把命令添加在编译部分，和打包部分中。<br>当然，这里还有个元数据的问题，和密匙的问题。<br>这是当你要自己写 PKGBUILD 文件是必须理解的两个东西。<br>关于 PKGBUILD 可以参考这两个模板 <a href="(https://aur.archlinux.org/cgit/aur.git/tree/PKGBUILD?h=dgedit-git)">dgedit-git.git</a> 和 <a href="(https://git.archlinux.org/svntogit/community.git/tree/trunk/PKGBUILD?h=packages/ncmpcpp)">ncmpcpp</a></p><h2 id="3-makepkg"><a href="#3-makepkg" class="headerlink" title="3. makepkg"></a>3. makepkg</h2><p><strong>配置</strong><br>可通过命令 <code># man makepkg.conf</code>来查询其详细的配置选项<br>makepkg 的主配置文件位于 /etc/makepkg.conf<br>用户自己的配置文件则会位于~/.makepkg.conf<br>建议用户在编译软件包之前检查该配置文件。</p><p>该配置文件中的内容选项<br>。。。</p><p><strong>打包人信息</strong><br>每个软件包都会有元数据信息，其中一箱就是打包人信息( packager)。<br>默认情况下，用户自己打包的软件标记为 Unknown Packager。<br>如果你要与他人共享自己的软件包，最好还是是提供真实的信息，<br>这可以在 makepkg.conf 文件中的 PACKAGER 变量来设置打包人的信息。</p><p>参考地址:<br><a href="https://wiki.archlinux.org/index.php/Makepkg" target="_blank" rel="noopener">https://wiki.archlinux.org/index.php/Makepkg</a><br><a href="https://wiki.archlinux.org/index.php/Creating_packages" target="_blank" rel="noopener">https://wiki.archlinux.org/index.php/Creating_packages</a></p><p><strong>非常抱歉，这一部分总结起来非常麻烦，涉及的太多。</strong><br><strong>一些方面还不是很懂，待我有空仔细研究一番再更新本文章。</strong></p><h2 id="4-pacman"><a href="#4-pacman" class="headerlink" title="4. pacman"></a>4. pacman</h2><p>以下这些是官方的内容，被我缩小并终结，但没有完全记录下来<br><strong>安装或升级单个软件包</strong><br><code>pacman -S name1, name2...</code><br><strong>指定 extra 库的软件安装</strong><br><code>pacman -S extra/name</code><br><strong>安装包组即包的内容包含其他东西</strong><br><code>pacman -S name</code><br><strong>选择序号安装</strong><br><code>Enter a selection (default=all): 1-10 15</code> 选中 1到10 和 15 的软件包<br><code>Enter a selection (default=all): ^5-8 ^2</code>  除了 5-8 和 2 的软件包<br><strong>查看哪些包属于包组</strong><br><code>pacman -Sg name</code><br><strong>删除软件包，保留其全部已经安装的依赖关系</strong><br><code>pacman -R name</code><br><strong>删除软件包，包括其所有没有被其他已经安装软件包使用的依赖关系</strong><br><code>pacman -Rs name</code><br><strong>删除软件包和所有依赖这个软件包的程序</strong><br><strong>注意，此操作是递归的，可能会删除大量的软件包</strong><br><code>pacan -Rsc name</code><br><strong>删除软件包，但是不删除依赖这个软件包的其他程序</strong><br><code>pacman -Rdd name</code><br><strong>删除某些程序时禁止备份重要的配置文件</strong><br><code>pacman -Rn name</code><br><strong>同步软件仓库，并升级整个系统</strong><br><code>pacman -Syu</code><br><strong>查询本地软件包数据库</strong><br><code>pacman -Q -help</code><br><strong>查询远程同步的数据库</strong><br><code>pacman -S -help</code><br><strong>在包数据库中查询软件包，查询条件包含软件包名和描述</strong><br><code>pacman -Ss name1, name2</code><br><strong>查询已经安装的软件包</strong><br><code>pacman -Qs name1, name2</code><br><strong>显示软件包的详细信息</strong><br><code>pacman -Si name</code><br><strong>查询本地安装包的详细信息</strong><br><code>pacman -Qi name</code><br><strong>获取已经安装的软件包所包含的文件列表</strong><br><code>pacman -Ql name</code><br><strong>检查软件安装包的文件是否存在</strong><br><code>pacman -Qk name</code><br><strong>如果要彻底检查</strong><br><code>pacman -Qkk name</code><br><strong>查询数据库获取某个文件属于哪个软件包</strong><br><code>pacman -Qo /path/name</code><br><strong>列出所有不再作为依赖的软件包（孤立包）</strong><br><code>pacman -Qdt</code><br><strong>列出所有明确被安装，而且不被其他包依赖的软件包</strong><br><code>pacman -Qet</code><br><strong>显示软件包的依赖树</strong><br><code>pactree name</code><br><strong>检查一个安装的软件包被哪些包所依赖</strong><br><code>pactree -r name</code><br>pacman 将下载的软件包保存在 <strong>/var/cache/pacman/pkg/</strong> 下，<br>并且不会移除旧的未安装版本的软件包，只保留软件包的当前有效版本，<br>以下命令可清除未安装的软件包缓存。<br><code>pacman -Sc</code><br><strong>如果要清理所有缓存，但在重装软件包的时候只能重新下载了</strong><br><code>pacman -Scc</code><br><strong>删除近3个版本前的软件包</strong><br><strong>自定义保留最近几个版本</strong><br><code>paccache -rk 2</code><br><strong>三处所有未安装的软件包缓存文件</strong><br><code>paccache -ruk0</code><br><strong>升级系统时安装其他软件包</strong><br><code>pacman -Syu name1, name2 ...</code><br><strong>下载包而不安装</strong><br><code>pacman -Sw name</code><br><strong>安装一个本地包，不从源里下载</strong><br><code>pacman -U /path/name.pkg.tar.xz</code><br><strong>将本地包保持到缓存</strong><br><code>pacman -U file://path/name.pkg.tar.xz</code><br><strong>安装一个远程包，不在 怕充满配置的源里面</strong><br><code>pacman -U http://www......</code><br><code>paccache -r</code><br><strong>查询一个包含具体文件的包名</strong><br><code>pacman -Fy</code><br><strong>查询某个文件的包名</strong><br><code>pacman -Fs pacman</code></p><p><strong>配置</strong><br>pacman 的配置文件位于 <strong>/etc/pacman.conf</strong><br>取消文件中的 <strong>VerbosePkglists</strong> 注释，可以在升级前对比新旧版本区别<br><strong>色彩输出</strong><br>取消注释 Color 行<br><strong>不升级软件包</strong><br>加入内容，<code>IgnorePkg = name1 name2 name3 ...</code>,<br>这些被忽略的可通过 <code>pacman -S</code> 升级<br><strong>不升级软件包组，同样也可以不升级单个软件包</strong><br>加入内容 <strong>IgnoreGroup= name1, name2, name3 …</strong></p><p><strong>软件仓库</strong><br>除了特殊的 <strong>options</strong> ，<br>每个 pacman.conf 中的 <strong>section</strong> 都定义了一个使用的软件包库，<br>仓库区分为官方和非官方两类，每个仓库都可以直接指定镜像列表。</p><p>pacman 数据库通常位于 <strong>/var/lib/pacman/sync</strong> ，<br>这里和 <strong>/etc/pacman.conf</strong> 总开启的软件仓库是一致的。<br>每个 tar.gz 文件都包含一个仓库的软件包</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>MarkDown 语法</title>
      <link href="/2017/06/07/MarkDown-%E8%AF%AD%E6%B3%95/"/>
      <url>/2017/06/07/MarkDown-%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h1><blockquote><p>   atx 形式标题(1 到 6 个 # 号，代表 1 至 6 级标题)<br>    # 一级标题<br>    …<br>    ###### 六级标题</p></blockquote><p>说明：<br>如果你想看起来更美观一点，可以在行尾添加数量不定的 # 号</p><blockquote><p>   # 一级标题 #<br>   ###### 六级标题 ######</p></blockquote><h1 id="区块引用"><a href="#区块引用" class="headerlink" title="区块引用"></a>区块引用</h1><ol><li><p>正常引用(每个行前加上 &gt; 号)</p><blockquote><p>   > 内容<br>   > 内容<br>   ><br>   > 内容</p></blockquote></li><li><p>懒人引用(在一个段落前只用一个 &gt; 号)</p><blockquote><p>   > 内容<br>   内容<br>   ><br>   > 内容<br>   内容</p></blockquote></li><li><p>嵌套引用(使用连续多个 &gt; 号来形成多级引用)</p><blockquote><p>   > 内容<br>   ><br>   > &gt; 嵌套内容<br>   ><br>   > 内容</p></blockquote></li><li><p>区块里包含其他 Markdown 语法</p><blockquote><p>   >    ## 这是一个标题。<br>   ><br>   >     1.   这是第一行列表项。<br>   >     2.   这是第二行列表项。<br>   ><br>   >     给出一些例子代码：<br>   ><br>   >        hexo new filename</p></blockquote></li></ol><p>说明:<br><em>使用区块引用会自动左对齐文本</em><br><em>如果 &gt; 后面是一个空行，空行将被保留</em></p><h1 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h1><ol><li>有序列表(使用数字，紧接一个英文句点 .) <blockquote><p>   1.内容<br>   2.内容<br>   3.内容</p></blockquote></li><li><p>无序列表(使用 * 、+、- 号)</p><blockquote><p>   + 内容<br>   + 内容</p></blockquote><blockquote><p>   - 内容<br>   - 内容</p></blockquote><blockquote><p>   * 内容<br>   * 内容</p></blockquote></li></ol><p>说明：<br><em>对于有序列表，数字可以随意写，但确保第一个列表为 1，输出结果会自动更改序号</em></p><blockquote><p>   例如：</p><blockquote><p>   1.内容<br>   8.内容<br>   4.内容</p></blockquote></blockquote><blockquote><p>   输出结果：</p><blockquote><p>   1.内容<br>   2.内容<br>   3.内容</p></blockquote></blockquote><p><em>列表会自动对齐，但如果你想更美观一点，除了序号行，其他行可以缩进最多三个空格</em></p><blockquote><p>   例如：</p><blockquote><p>   1.内容<br>   内容<br>   2.内容<br>   内容</p></blockquote></blockquote><blockquote><p>   可以缩进三个空格来美观</p><blockquote><p>   1.内容<br>      内容<br>   2.内容<br>      内容</p></blockquote></blockquote><blockquote><p>   无论以上哪种，输出结果自动对齐：</p><blockquote><p>   1.内容<br>        内容<br>   2.内容<br>        内容</p></blockquote></blockquote><p><em>如果两个列表项的内容之间是用空行分开的，空行会被保留</em><br><em>列表标记后面只能是一个空格或者一个制表符</em></p><blockquote><p>   1.内容<br>   *    内容</p></blockquote><p><em>如果列表项内要放入引用，则 &gt; 号也必须缩进，即一个制表符</em></p><blockquote><p>1.内容<br>   > 引用<br>   > 引用</p></blockquote><p><em>如果列表项内要放入代码块的话，代码就要被缩进两次，8 个空格或 2 个制表符</em></p><blockquote><p>1.内容<br>       代码</p></blockquote><p><em>包含段落，每个列表项下的每个段落可以缩进 4 个空格或者一个制表符</em></p><blockquote><p>   1.段落1<br>   段落1</p><p>   段落2<br>   段落2<br>   2.内容</p></blockquote><h1 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h1><ol><li><p>代码缩进一个制表符</p><blockquote><p>   内容：<br>   代码</p></blockquote></li><li><p>三个反引号，输出结果的代码附加序号</p><blockquote><p>   ```<br>   代码1<br>   代码2<br>   ```</p></blockquote></li></ol><h1 id="分割线-—-星号、减号、底线"><a href="#分割线-—-星号、减号、底线" class="headerlink" title="分割线 —- 星号、减号、底线"></a>分割线 —- 星号、减号、底线</h1><blockquote><p>   * * *<br>   ***<br>   *****<br>   - - -<br>   -————————————–</p></blockquote><p>说明：<br>行内不能有其他东西，但可以星号或减号中间插入空格</p><h1 id="链接-行内式、参考式，不管哪一种，链接文字用-括起来"><a href="#链接-行内式、参考式，不管哪一种，链接文字用-括起来" class="headerlink" title="链接(行内式、参考式，不管哪一种，链接文字用 [ ] 括起来)"></a>链接(行内式、参考式，不管哪一种，链接文字用 [ ] 括起来)</h1><ol><li><p>行内式(在方括号紧接着圆括号内插入网址或链接)</p><blockquote><p>   <strong>[</strong>要被点击的内容<strong>]</strong> <strong>(</strong>被点击后要跳转的链接<strong>)</strong></p></blockquote><p> 要在鼠标停留时显示链接的标题则用双引号引用链接里的标题</p><blockquote><p>   <strong>[</strong>要被点击的内容<strong>]</strong> <strong>(</strong>这是一个链接<strong>“</strong>这是网站的标题<strong>“</strong> <strong>)</strong></p></blockquote><p> 如果要跳转的链接是站内地址，可以使用相对路径</p><blockquote><p>   跳转<strong>[</strong>关于页面<strong>]</strong> <strong>(</strong>/about/<strong>)</strong></p></blockquote></li><li><p>参考式(在方括号内再加上方括号，然后在文件任意位置定义或指出链接)</p><blockquote><p>   <strong>[</strong>这是要被点击的内容<strong>\</strong>] <strong>[</strong>这是内部标记名id<strong>]</strong><br> 在文件任意位置例如文件结尾<br>   <strong>[</strong>内部标记名id<strong>]</strong>: 链接地址 “需要还可包括标题”</p></blockquote></li><li><p>隐式链接(根据第一个方括号的内容来寻找定义的链接) </p><blockquote><p>   <strong>[</strong>Google<strong>]</strong> <strong>[</strong> <strong>]</strong><br>   定义内容：<br>   <strong>[</strong>Google<strong>]</strong>:    <a href="https://www.google.com/" target="_blank" rel="noopener">https://www.google.com/</a></p></blockquote></li></ol><p>注意：<br><em>参考方括号前面可以选择性的加上最多三个空格</em><br><em>格式顺序</em></p><blockquote><p>   方括号后面要接着冒号<br>   冒号后面一个空格或制表符<br>   链接地址<br>    选择性的添加标题内容，可用双引号，圆括号包围起来</p></blockquote><p><em>链接地址可以用 &lt;括起来&gt;</em><br><em>可以把标题放在下一行，甚至还可缩进，用于解决网址过长的美观</em><br><em>定义的链接不会包含在网页上的内容中</em><br><em>要被点击的内容中可以有字母、数字、空白、标点符号、但是不区分大小写</em></p><h1 id="强调-、-、作为标记强调字或词"><a href="#强调-、-、作为标记强调字或词" class="headerlink" title="强调(* 、_ 、作为标记强调字或词)"></a>强调(* 、_ 、作为标记强调字或词)</h1><ol><li>一个 * 和 一个 _<blockquote><p>   *内容*<br>   _内容_</p></blockquote></li><li>两个 * 和 两个_<blockquote><p>   **内容**<br>   __内容__</p></blockquote></li></ol><p>注意：<br><em>强调可以插在文字中间</em><br><em>如果 </em> 和 _ 两边都有空白的话，就被当成普通符号<em></em>反斜杠可以解决符号被当成内部代码的问题从而输出符号*</p><h1 id="标记代码"><a href="#标记代码" class="headerlink" title="标记代码"></a>标记代码</h1><p><em>如果要标记代码行内一小段代码，用 反引号 `包围起来`</em></p><blockquote><p>   Use the `printf()` function.</p></blockquote><p><em>如果要在输出结果中附带 <code>号，则使用 ``</code> 多个 反引号</em></p><blockquote><p>   `` 代码`abc`add``<br>   输出结果为：代码`agc`add</p></blockquote><h1 id="图片链接，参考链接那部分"><a href="#图片链接，参考链接那部分" class="headerlink" title="图片链接，参考链接那部分"></a>图片链接，参考链接那部分</h1><p>只需在图片前面附加 ! 号，形式如下</p><blockquote><p>   <strong>!</strong> <strong>[</strong>图片名<strong>]</strong> <strong>(</strong>图片地址<strong>)</strong></p></blockquote><p>也可以<strong>参考形式</strong>和<strong>隐式链接</strong></p><blockquote><p>   ![图片名][id] <em>或者</em>  ![图片名][]<br>然后定义<br>   [id]: 图片地址    “图片名” <em>或者</em>   [图片名]: 图片地址</p></blockquote><h1 id="自动链接-将文字转换为链接"><a href="#自动链接-将文字转换为链接" class="headerlink" title="自动链接(将文字转换为链接)"></a>自动链接(将文字转换为链接)</h1><blockquote><p>   &lt; <a href="http://www.google.com" target="_blank" rel="noopener">http://www.google.com</a> > 带下划线</p></blockquote><h1 id="反斜杠用于转义一系列无法输出的标点符号"><a href="#反斜杠用于转义一系列无法输出的标点符号" class="headerlink" title="\ 反斜杠用于转义一系列无法输出的标点符号"></a>\ 反斜杠用于转义一系列无法输出的标点符号</h1>]]></content>
      
      
      <categories>
          
          <category> Markdown 系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Arch 包管理</title>
      <link href="/2017/06/07/%E5%8C%85%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6-1-Arch/"/>
      <url>/2017/06/07/%E5%8C%85%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6-1-Arch/</url>
      
        <content type="html"><![CDATA[<p>我才刚接触  Arch 发行版差不多一个月，都说玩这系统的在包管理这一部分都是必修课！<br>因此作者特地搜查了各方面的资料，并做了一系列的总结，希望给需要的人一些参考！<br>由于本章篇幅有限，并不能涵盖所有知识，因此我只针对几个重点的来讲。<br>然而要认识 Arch 的 包管理机制，我们还需要从源代码开始讲。<br><strong>源代码</strong><br>我们知道所有 Linux/Unix 类系统在最初的时候安装一个软件都是用源代码来安装的。<br>但由于这个过程太过于乏味，或者说麻烦，甚至效率不高，因此便有了各种各样的包管理器！<br>而每个系统都有自己的一个包管理机制。尽管各系统之间的包管理器都有些差异，但相同的是<br>包管理器只是简化了从源代码安装软件的过程的一种工具。以下，我将带你走进 Arch 的核心。</p><h2 id="1-从源代码安装软件"><a href="#1-从源代码安装软件" class="headerlink" title="1. 从源代码安装软件"></a>1. 从源代码安装软件</h2><p>软件，是别人写出来的，并根据一定的许可证而开放出了源代码。<br>当你拿到了这个源码包，你就可以将这个软件安装在自己的系统上以供日常使用。<br>从源代码安装一个软件不过是以下几个步骤：<br><strong>1.    到官方(发布者网站)下载源代码且解压得到源码的目录结构。</strong><br><strong>2.    进行安装之前的路径配置以及一些其他的设定。</strong><br><strong>3.    在源码根目录下编译所有源码文件且生成可执行文件</strong><br><strong>4.    将编译好的可执行文件(有时候还包括库文件、资源文件等)进行打包，或者安装到自己的系统中</strong><br>于是，在用源代码来安装一个软件的时候，也就是以下这个过程：<br><strong>配置(configure)</strong> -&gt; <strong>编译(make)</strong> -&gt; <strong>安装(make install)</strong><br>关于详细的源代码安装过程，我将在<a href="(http://www.guib.in/archives/)" title="暂未更新">下一章</a>详细解释。</p><h2 id="2-PKGBUILD-是什么"><a href="#2-PKGBUILD-是什么" class="headerlink" title="2. PKGBUILD 是什么"></a>2. PKGBUILD 是什么</h2><p><a href="(https://wiki.archlinux.org/index.php/PKGBUILD)" title="到官方 Wiki 查看 PKGBUILD">PKGBUILD</a> 只是是一个文本文件，它是 Arch 特有的一种机制。<br>该文件包含以下三部分:<br><strong>1. 软件包的基本信息</strong><br><strong>2. 指定软件源码包的路径</strong><br><strong>3. 软件包要如何编译和打包</strong><br>其实 <a href="(https://wiki.archlinux.org/index.php/PKGBUILD)" title="到官方 Wiki 查看 PKGBUILD">PKGBUILD</a> 文件的灵活性非常高，用处非常之多。但这里不过多阐述。<br><strong>注意：为你让你明白，这里简化了一些细节，<a href="(http://www.guib.in/archives/)" title="暂未更新">下一章</a>我将详细介绍该文件的内容。</strong><br>可以看出，整个源码安装的过程都被包含在这个文件中。<br>实际上它负责提供了能够完成安装软件的一系列信息。<br>可能你已经猜出 一二了，但在真正告诉你之前，我们来看看 <a href="(https://wiki.archlinux.org/index.php/Pacman)" title="到官方 Wiki 查看 pacman">pacman</a>。</p><h2 id="3-pacman"><a href="#3-pacman" class="headerlink" title="3. pacman"></a>3. pacman</h2><p>这个东西，我不用多解释，你能安装完整个系统并进行使用，你就已经接触过它好几次了。<br>但我们还是稍微讲几个重点的，<a href="(https://wiki.archlinux.org/index.php/Pacman)" title="到官方 Wiki 查看 pacman">pacman</a> 是一个包管理器，<br>它只认识 name.pkg.tar.xz 或者 name.pkg.tar.gz 这两种格式的文件，以下将选择其中一种格式来讲。<br>当我们执行 <code>\# pacman -Sy</code> 的时候，它从 Arch 官方仓库下载已经编译好的 name.pkg.tar.gz 软件包。<br>当我们执行 <code>\# pacman -S</code> 的时候，它解压 .pkg.tar.gz 包，并根据安装信息拷贝到指定的系统目录中。<br>换句话说，<a href="(https://wiki.archlinux.org/index.php/Pacman)" title="到官方 Wiki 查看 pacman">pacman</a> 它只负责安装一个软件包，并且只能读取 .pkg.tar.xz 或 .pkg.tar.gz 格式的文件<br>而且，.pkg.tar.xz 或 pkg.tar.gz 包内必须是已经被编译过的软件目录结构。</p><h2 id="4-AUR"><a href="#4-AUR" class="headerlink" title="4. AUR"></a>4. AUR</h2><p><a href="(https://aur.archlinux.org/)" title="AUR 仓库">AUR</a> 是一个社区仓库，简单点说，它就是一个仓库源。<br>这个仓库很有意思，你可以上传你自己编写的，或是经过修改(再发布的)软件到这个仓库与大家共享。<br>你也可以从上面下载别人共享的各种软件包来安装和使用。据说仓库里资源非常丰富，几乎你想要的都有。<br>我们知道，在 Linux 类系统下一个源码包占用的体积不大，但是久而久之，随着源码包的数量增多，<br>其容量也不可忽视。而且投资成本会增高。并且软件作者还得总是上传源码包到 AUR 仓库中。<br>于是官方想出了一个两全之策，官方使用一种机制，即用一个文件来保存一系列信息，<br>这些信息包括了 软件名、从哪获取软件包(下载地址)、依赖于哪些包(包括依赖包的下载地址)、<br>以及验证软件包的完整性密匙 和 编译安装或者是打包需要的信息。<br>这个文件很好的解决了投资成本，也方便了软件开发者，软件共享者和软件下载使用者。<br>于是，官方服务器不需要维护一系列源码包，而只需要保存一系列文本文件，<br>开发者只需要上传一个 几 k 的文件，下载使用者只需要下载一个文件便可安装软件了。<br>如果你现在到 <a href="(https://aur.archlinux.org/)" title="AUR 仓库">AUR</a> 仓库下载任何一个软件，下载到的就是一个文件，<br>而这个文件就是 <a href="(https://wiki.archlinux.org/index.php/PKGBUILD)" title="到官方 Wiki 查看 PKGBUILD">PKGBUILD</a> 文件 ！</p><h2 id="5-makepkg-是什么"><a href="#5-makepkg-是什么" class="headerlink" title="5. makepkg 是什么"></a>5. makepkg 是什么</h2><p>最好的总是留在最后讲，终于要讲最核心的部分了，但是，很快就会讲完了。<br>没错，整个核心，就是 <a href="(https://wiki.archlinux.org/index.php/Makepkg)" title="到官方 Wiki 查看 makepkg">makepkg</a>。<br><a href="(https://wiki.archlinux.org/index.php/Makepkg)" title="到官方 Wiki 查看 makepkg">makepkg</a> 其实只是一个工具，这个工具它只能读取 <a href="(https://wiki.archlinux.org/index.php/PKGBUILD)" title="到官方 Wiki 查看 PKGBUILD">PKGBUILD</a> 文件。<br>我们知道，<a href="(https://wiki.archlinux.org/index.php/PKGBUILD)" title="到官方 Wiki 查看 PKGBUILD">PKGBUILD</a> 文件整体包含三部分: </p><blockquote><p>软件的基本信息，<br>软件的获取位置，<br>软件的编译和打包方式</p></blockquote><p>现在让我们来看看这个命令工具的运行过程：<br>当你在 <a href="(https://wiki.archlinux.org/index.php/PKGBUILD)" title="到官方 Wiki 查看 PKGBUILD">PKGBUILD</a> 文件根目录下执行 <code># makepkg</code> 时，它是这样的<br><strong>1. 根据软件获取地址，从网上下载，或到指定的位置寻找源码包，并验证完整性</strong><br><strong>2. 把源码包按固定的本地路径进行解压，并根据基本信息部分来创建与软件包相同名字的目录</strong><br><strong>3. 按照编译部分，把软件进行编译，并打包为 .pkg.tar.gz 文件格式并保存在当前目录下。</strong><br>现在，我们可以使用 <a href="(https://wiki.archlinux.org/index.php/Makepkg)" title="到官方 Wiki 查看 makepkg">makepkg</a> 来安装它，也可以使用 <a href="(https://wiki.archlinux.org/index.php/Pacman)" title="到官方 Wiki 查看 pacman">pacman</a> 来安装这个软件。<br>当你使用 makepkg 来安装软件的时候，实际上也是调用了 <a href="(https://wiki.archlinux.org/index.php/Pacman)" title="到官方 Wiki 查看 pacman">pacman</a> 来进行安装。<br><a href="(https://wiki.archlinux.org/index.php/Makepkg)" title="到官方 Wiki 查看 makepkg">makepkg</a> 本身只负责读取 <a href="(https://wiki.archlinux.org/index.php/PKGBUILD)" title="到官方 Wiki 查看 PKGBUILD">PKGBUILD</a> 文件，并根据其中的信息来下载，编译，打包，但它不会安装软件。</p><p>其实就是这么一回事。重点都在上面已经讲过了。<br>更多详细的部分，会留在<a href="(http://www.guib.in/archives/)" title="暂未更新">下一章</a>进行详细分析这几个东西。<br>以下 <a href="(https://wiki.archlinux.org/index.php/Arch_Build_System)" title="到官方 Wiki 查看 ABS">ABS</a>、<a href="(https://archlinux.fr/yaourt-en)" title="安装方法">yaourt</a> 是附加的，你可以了解一下。</p><h2 id="6-yaourt-工具"><a href="#6-yaourt-工具" class="headerlink" title="6. yaourt 工具"></a>6. yaourt 工具</h2><p>如标题所示，<a href="(https://archlinux.fr/yaourt-en)" title="安装方法">yaourt</a> 是一个工具。如果你要使用它，你还得<a href="(https://archlinux.fr/yaourt-en)" title="安装方法">安装</a>它。<br><a href="(https://archlinux.fr/yaourt-en)" title="安装方法">yaourt</a> 工具同样也只认识 <a href="(https://wiki.archlinux.org/index.php/PKGBUILD)" title="到官方 Wiki 查看 PKGBUILD">PKGBUILD</a> 文件，<br>这个工具根据 <a href="(https://wiki.archlinux.org/index.php/PKGBUILD)" title="到官方 Wiki 查看 PKGBUILD">PKGBUILD</a> 文件内容，自动下载软件包，编译，打包，安装。<br>这是基本的，此外，还有其他一些很实用的功能，这里不再阐述。<a href="(https://wiki.archlinux.org/)" title="官方 Wiki">Wiki</a>可以了解更多。<br>可以看出，<a href="(https://archlinux.fr/yaourt-en)" title="安装方法">yaourt</a> 其实就是简化 <a href="(https://wiki.archlinux.org/index.php/Makepkg)" title="到官方 Wiki 查看 makepkg">makepkg</a> 命令和 <a href="(https://wiki.archlinux.org/index.php/Pacman)" title="到官方 Wiki 查看 pacman">pacman</a> 命令的一个存在。<br>实现全自动化从 <a href="(https://aur.archlinux.org/)" title="AUR 仓库">AUR</a> 搜索软件包并安装，而不用自己下载软件的 <a href="(https://wiki.archlinux.org/index.php/PKGBUILD)" title="到官方 Wiki 查看 PKGBUILD">PKGBUILD</a> 文件。<br>其实 <a href="(https://archlinux.fr/yaourt-en)" title="安装方法">yaourt</a> 就是把 <a href="(https://aur.archlinux.org/)" title="AUR 仓库">AUR</a> 和 <a href="(https://wiki.archlinux.org/index.php/Makepkg)" title="到官方 Wiki 查看 makepkg">makepkg</a>、<a href="(https://wiki.archlinux.org/index.php/Pacman)" title="到官方 Wiki 查看 pacman">pacman</a> 结合在一起的一个存在。<br>因此在 <a href="(https://archlinux.fr/yaourt-en)" title="安装方法">yaourt</a> 中安装 <a href="(https://aur.archlinux.org/)" title="AUR 仓库">AUR</a> 源中的软件非常方便。</p><h2 id="7-ABS-是什么"><a href="#7-ABS-是什么" class="headerlink" title="7. ABS 是什么"></a>7. ABS 是什么</h2><p>首先我们来重复一下 <a href="(https://aur.archlinux.org/)" title="AUR 仓库">AUR</a><br><a href="(https://aur.archlinux.org/)" title="AUR 仓库">AUR</a> 的全称为 <strong>Archlinux User-community Repository</strong><br>也就是 <a href="(https://www.archlinux.org/)" title="ArchLinux 官方网站">ArchLinux</a> 用户社区的软件库。<br>当你要安装软件的时候，你得从 <a href="(https://aur.archlinux.org/)" title="AUR 仓库">AUR</a> 源里下载 <a href="(https://wiki.archlinux.org/index.php/PKGBUILD)" title="到官方 Wiki 查看 PKGBUILD">PKGBUILD</a> 文件，再进行安装。<br>当你修改了一个软件且成功编译和安装，你想把这个修改的软件分享给所有 Arch 用户，<br>你得登录到 <a href="(https://aur.archlinux.org/)" title="AUR 仓库">AUR</a> 仓库然后进行上传，大家才能看到你的 <a href="(https://wiki.archlinux.org/index.php/PKGBUILD)" title="到官方 Wiki 查看 PKGBUILD">PKGBUILD</a> 文件。才能共享出去。</p><p><strong>接着我们来了解一些官方的仓库</strong><br>当你在命令行中执行这个命令 <code># pacman -Syu</code> 或者是 <code># pacman -Sy</code> 时<br>就会看到如下输出：</p><blockquote><p>core ….<br>extra    ….<br>community    …..</p></blockquote><p><strong><a href="(https://wiki.archlinux.org/index.php/Official_repositories)" title="官方详解">core</a>: 官方仓库，内包含构建一个基本系统必须的所有组件或软件，即系统的核心软件仓库。</strong><br><strong><a href="(https://wiki.archlinux.org/index.php/Official_repositories)" title="官方详解">extra</a>: 官方仓库，内包含构建一个基本系统非必须的一些用户常用软件，即常用软件仓库。</strong><br><strong><a href="(https://wiki.archlinux.org/index.php/Official_repositories)" title="官方详解">community</a>: 社区仓库，内包含的软件大都是从 AUR 仓库那投票进来的且都是可被信任的。</strong><br><strong><a href="(https://aur.archlinux.org/)" title="AUR 仓库">AUR</a>: 非官方仓库，面向广大 Arch 用户的非官方仓库，所有用户自由上传/下载软件包。</strong></p><p>其实这些都是 Arch 的仓库，或者说是软件库也行。其实仓库不止这这些，<br>但无论如何，<a href="(https://wiki.archlinux.org/index.php/Official_repositories)" title="官方详解">core</a> 和 <a href="(https://wiki.archlinux.org/index.php/Official_repositories)" title="官方详解">extra</a> 仓库由 Arch 的 核心人员维护，即官方软件仓库。<br>此外，还有 <a href="(https://wiki.archlinux.org/index.php/Official_repositories)" title="官方详解">multilib</a> 仓库则包含了 64 位系统中包含的 32 位软件和32位库<br>而 <a href="(https://wiki.archlinux.org/index.php/Official_repositories)" title="官方详解">testing</a> 仓库、<a href="(https://wiki.archlinux.org/index.php/Official_repositories)" title="官方详解">community-testing</a> 仓库 和 <a href="(https://wiki.archlinux.org/index.php/Official_repositories)" title="官方详解">multilib-testing</a> 仓库<br>它们构成了 <a href="(https://wiki.archlinux.org/index.php/Official_repositories)" title="官方详解">texting</a> 系列的仓库。主要用于在移到正式仓库之前的软件包作为测试的一类仓库。<br>正是由于 <a href="(https://aur.archlinux.org/)" title="AUR 仓库">AUR</a> 是非官方仓库，因此不在 <a href="(https://wiki.archlinux.org/index.php/Pacman)" title="到官方 Wiki 查看 pacman">pacman</a> 的更新列表里。所以 <a href="(https://archlinux.fr/yaourt-en)" title="安装方法">yaourt</a> 才为此提供了方便。</p><p><a href="(https://wiki.archlinux.org/index.php/Arch_Build_System)" title="到官方 Wiki 查看 ABS">ABS</a> 全称 <strong>Archlinux Build System</strong> 即一个编译系统。<br>它的作用就是从 <a href="(https://wiki.archlinux.org/index.php/Official_repositories)" title="官方详解">core</a>、<a href="(https://wiki.archlinux.org/index.php/Official_repositories)" title="官方详解">extra</a>、<a href="(https://wiki.archlinux.org/index.php/Official_repositories)" title="官方详解">community</a> 三个仓库中同步/下载 <a href="(https://wiki.archlinux.org/index.php/PKGBUILD)" title="到官方 Wiki 查看 PKGBUILD">PKGBUILD</a> 文件到本地，<br>当你要安装某个软件的时候，就到 [ABS[]] 目录(与官方目录是相同的)下找到你需要的软件的 <a href="(https://wiki.archlinux.org/index.php/PKGBUILD)" title="到官方 Wiki 查看 PKGBUILD">PKGBUILD</a> 文件，<br>为了不改变原来的文件，你可以拷贝到自己home目录下的子目录中，接着你就可以运行 <a href="(https://wiki.archlinux.org/index.php/Makepkg)" title="到官方 Wiki 查看 makepkg">makepkg</a> 命令<br>和 <a href="(https://wiki.archlinux.org/index.php/Pacman)" title="到官方 Wiki 查看 pacman">pacman</a> 命令来安装了。好处在哪？？？？？？<br><strong>1. 你可以从源码安装软件包，而非编译好的二进制包。</strong><br><strong>2. 在安装过程中，你可以自己编辑 <a href="(https://wiki.archlinux.org/index.php/PKGBUILD)" title="到官方 Wiki 查看 PKGBUILD">PKGBUILD</a> 文件来按自己的需求安装某个软件。</strong><br><strong>3. 可以方便你在不影响原来的文件的情况下测试和修改一些软件，以达到自己的需求。</strong></p><p>但是遗憾的是，<a href="(https://www.archlinux.org/)" title="ArchLinux 官方网站">ArchLinux</a> 官方在 2017-08-15 日宣布放弃支持 <a href="(https://wiki.archlinux.org/index.php/Arch_Build_System)" title="到官方 Wiki 查看 ABS">ABS</a> 了。<br>可以忽略这一部分，当然，了解一下这个伟大的一个机制也是个不错的选择。<br>我可惜的是，当我开始玩 Arch 的时候 <a href="(https://wiki.archlinux.org/index.php/Arch_Build_System)" title="到官方 Wiki 查看 ABS">ABS</a> 就被放弃了。据说有个替代品。<br>你可到这里看一下: <a href="https://www.archlinux.org/news/deprecation-of-abs/" target="_blank" rel="noopener">https://www.archlinux.org/news/deprecation-of-abs/</a></p><p><strong>补充：</strong><br>了解一下 ABS 的目录结构，实际上也是官方仓库的目录结构。<br>ABS 分三级目录：</p><blockquote><p>一级目录: 是软件的仓库名，core、extra、community 三个文件夹<br>二级目录: 是各个仓库下的软件名，是以软件命名的文件夹。<br>三级目录: 是一个 PKGBUILD 文件 (有时可能还包含一些其它相关的补丁或其它打包所需的文件)</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>AUR 为了解决了官方问题，和方便了所有人而提供了 PKGBUILD 文件机制</strong><br><strong>PKGBUILD：</strong></p><blockquote><p>   <em>1. 减少了服务器负担，和投资成本</em><br>   <em>2. 方便了所有人下载/上传软件源码的过程</em><br>   <em>3. 同时还简化了从源码安装软件的过程</em></p></blockquote><p><strong>makepkg 命令替代了 make 命令 和 make install 是对 PKGBUILD 文件的一个实际动作。</strong><br><strong>pacman 命令只负责安装已被编译好且被打包为 .pkg.tar.gz 或 .pkg.tar.xz 格式的软件包。</strong><br><strong>ABS 是更方便的让你下载安装软件和上传共享软件的一个平台，或者说是一套系统。</strong></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Arch-配置过程</title>
      <link href="/2017/05/28/%E9%85%8D%E7%BD%AE%E8%BF%87%E7%A8%8B-Arch/"/>
      <url>/2017/05/28/%E9%85%8D%E7%BD%AE%E8%BF%87%E7%A8%8B-Arch/</url>
      
        <content type="html"><![CDATA[<h2 id="用户环境配置"><a href="#用户环境配置" class="headerlink" title="用户环境配置"></a>用户环境配置</h2><ul><li><p><strong>1 以root 用户登陆</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@ 输入刚才设置的 root 密码</span><br></pre></td></tr></table></figure></li><li><p><strong>2 增加用户及设置密码</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@ echo $SHELL // 输出 bash 路径记住,以下假设是 /bin/bash</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>   // WORKS 为用户组，Wroks 为 用户名，/bin/bash 为 第一条命令的执行结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@ useradd -m -g WORKS -s /bin/bash Works</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>   // 考虑到提升权限，也可以添加进 whell 组，如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@ useradd -m -g WORKS -G whell -S /bin/bash Works</span><br></pre></td></tr></table></figure></p></blockquote><ul><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@ passwd Works// 设置新用户密码</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>注意：</p><blockquote><p>开始我不知道，直接使用了第一种创建用户，即没有加入 whell 组<br>后来知道了其中的缘由，所以才给出了 第二种创建用户的方法<br>详情看以下 sudo</p></blockquote></blockquote><ul><li><strong>3 sudo 配置</strong><br>默认 base 包组已经安装了 sudo 软件包<br>如果没有则安装之<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@pacman -S sudo</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>编辑 /etc/sudoers 文件进行修改<br>两种修改方式</p><blockquote><p>A.添加一条 Works ALL=(ALL) ALL        // Works 是用户名<br>B.去掉 #%whell ALL=(ALL) ALL 前的注释号 #</p></blockquote></blockquote><blockquote><p>对于 B 的前提是用户已经加入 whell 组</p></blockquote><ul><li>另外，你还可以设置sudo密码的过期时间等，详参考<a href="https://wiki.archlinux.org/index.php/Sudo" target="_blank" rel="noopener">官方Wiki</a></li></ul><ul><li><strong>4 安装显卡</strong><br>建议安装开源驱动，闭源驱动总是出现很多奇怪的问题，但也不一定是没问题<br>至少我总是出现问题。<br>如果你也是 N 卡，则执行以下<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@ pacman -S xf86-video-nouveau // 我的N卡型号为 GTX660 Ti</span><br></pre></td></tr></table></figure></li></ul><p>对于其他型号已经其他显卡清参照<a href="https://wiki.archlinux.org/index.php/Xorg" target="_blank" rel="noopener">官方</a>进行安装</p><ul><li><strong>6 安装 X11 图形服务，我使用 Xorg</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@ pacman -S xorg// 你可以选择需要的进行安装,我是默认全部安装</span><br></pre></td></tr></table></figure></li></ul><p>或者，可以这样安装，但我没试过：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@ pacman -S xorg-server xorg-server-utils xorg-init</span><br></pre></td></tr></table></figure></p><p><strong>xorg 是安装图形界面之前必须的</strong></p><ul><li><strong>7 安装桌面环境 GNOME</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@ pacman -S gnome // 默认安装三个桌面</span><br><span class="line">root@ pacman -S gnome-extra// 安装标准桌面+常用软件</span><br></pre></td></tr></table></figure></li></ul><p>以上二选一安装，对于其他桌面请<a href="https://wiki.archlinux.org/index.php/Desktop_environment" target="_blank" rel="noopener">参考官方</a></p><ul><li><p><strong>8 安装 GDM</strong> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@ pacman -S gdm// 安装 gdm 登陆管理器</span><br><span class="line">root@ systemctl enable gdm // 开机自启动 gdm 管理器</span><br><span class="line">root@ systemctl enable NetworkManager.service // 开机自启动网络管理</span><br></pre></td></tr></table></figure></li><li><p><strong>9 重启</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@ reboot// 重启</span><br></pre></td></tr></table></figure></li></ul><p>到这里，你已经可以启动到图形界面！<br>以下的设置你可以作为参考！</p><h2 id="系统美化方案及一些常用设置"><a href="#系统美化方案及一些常用设置" class="headerlink" title="系统美化方案及一些常用设置"></a>系统美化方案及一些常用设置</h2><blockquote><p>注意:</p><blockquote><p>以下都需要加上 sudo ，因为是在普通用户下执行操作，不建议在 root 用户下进行操作<br>如果一些设置(例如安装输入法等)无法及时生效，可重启一下！</p></blockquote></blockquote><ul><li><p><strong>1 字体</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@ pacman -S wqy-zenhei // 文泉字体</span><br><span class="line">root@ pacman -S adobe-source-han-sans-cn-fonts // 可选思源黑体</span><br><span class="line">root@ pacman -S wqy-microhei // 忘记了</span><br></pre></td></tr></table></figure></li><li><p><strong>2 安装输入法</strong></p><ul><li><strong>A.IBUS</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@ pacman -S ibus// 安装 ibus</span><br><span class="line">root@ pacman -S ibus-pinyin// 安装输入法支持输入中文</span><br><span class="line"> 或者</span><br><span class="line">root@ pacman -S lib-ibus-pinyin// 中文支持库，好像是</span><br></pre></td></tr></table></figure></li></ul></li></ul><blockquote><p>一般情况下重启后会自启动ibus<br>如果没有则在 ～/bashrc 添加以下代码</p><blockquote><p>export GTK_IM_MODULE=ibus<br>export XMODIFIERS=@im=ibus<br>export QT_IM_MODULE=ibus</p></blockquote></blockquote><blockquote><p>或者图形界面找到 ibus 首选项，添加输入法</p></blockquote><ul><li><strong>B.FCITX</strong><br>安装之前请确保已经禁用 ibus(有坑)<br>此禁用ibus的方法已经失效，如有其他方法请发邮件告诉我，我通过删除 ibus 而解决的<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@ gsettings set org.gnome.settings-daemon.plugins.keyboard active false// 禁用 ibus</span><br></pre></td></tr></table></figure></li></ul><ul><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@ pacman -S fcitx-im fcitx-configtool// 安装 fcitx 和 设置</span><br><span class="line">root@ pacman -S fictx-sogoupinyin// 安装搜狗拼音</span><br><span class="line">root@ fcitx-configtool// 添加搜狗拼音</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>另外在对于 GNOME GDM 管理器 请在~/.xprofile 文件中输入以下(没有该文件则创建之)</p><blockquote><p>export GTK_IM_MODULE=fcitx<br>export QT_IM_MODULE=fcitx<br>export XMODIFIERS=”@im=fcitx”</p></blockquote></blockquote><p>重启即可</p><blockquote><ul><li><strong>安装 fcitx 后的几个问题</strong></li></ul><ol><li>左下角多出了一个系统托盘，而顶部条则没有，暂时不知道如何配置</li><li>Shift 切换输入法为英文输入法时，状态条总是显示不会隐藏</li><li>在终端输入 fcitx -r 后，会临时没有左下角托盘，且切换输入法为英文时状态条自动消失，短时间后又恢复了<br>如果你已经解决了上面的问题请发邮件给我谢谢！</li></ol></blockquote><ul><li><strong>3 安装 AUR 源，包管理 yaourt</strong><br>网上查找很多资料都说编辑 /etc/pacman.conf 文件加入 </li></ul><blockquote><blockquote><p>[archlinuxcn]<br>root@The Chinese Arch Linux communities packages.<br>SigLevel = Optional TrustAll<br>Server = <a href="https://mirrors.ustc.edu.cn/archlinuxcn/$arch" target="_blank" rel="noopener">https://mirrors.ustc.edu.cn/archlinuxcn/$arch</a></p></blockquote></blockquote><blockquote><p>然后执行 # pacman -Syu yaourt 即可。你可尝试一下。<br>但我屡试不行，最后的解决方法如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">root@ cd home// 在home 目录下操作</span><br><span class="line">root@ mkdir yurt// 新建一个空文件夹准备操作</span><br><span class="line">root@ cd yurt// 进入该空文件夹</span><br><span class="line">root@ git clone https://aur.archlinux.org/package-query.git// 下载 package-query 软件包</span><br><span class="line">root@ cd package-query// 进入该软件包</span><br><span class="line">root@ makepkg -si// 编译s并安装i</span><br><span class="line">root@ cd ..// 回到上一层目录</span><br><span class="line">root@ git clone https://aur.archlinux.org/yaourt.git// 下载 yaourt 软件包</span><br><span class="line">root@ cd yaourt// 进入该软件包</span><br><span class="line">root@ makepkg si// 编译s并安装i</span><br><span class="line">root@ yaourt -Syu -devel -aur// 同步数据库、升级包、搜索 AUR</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>则成功安装了 yaourt 。<br>参考的地址为： <a href="https://archlinux.fr/yaourt-en" target="_blank" rel="noopener">https://archlinux.fr/yaourt-en</a></p></blockquote><ul><li><p><strong>3 一些常用软件</strong></p><ul><li><p><strong>A.p7zip    解压 zip 文件</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@ pacman -S p7zip</span><br></pre></td></tr></table></figure></li><li><p><strong>B.GNOME 软件中心</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@ pacman -S gnome-s -oftware</span><br></pre></td></tr></table></figure></li><li><p><strong>C.zim 桌面维基，用于记录笔记和文档</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@ pacman -S</span><br></pre></td></tr></table></figure></li><li><p><strong>D. Firefox    火狐浏览器</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@ pacman -S firefox</span><br></pre></td></tr></table></figure></li><li><p><strong>E.chrome    谷歌浏览器</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@ yaourt -S google-chrome// 前提要翻墙参见后面翻墙</span><br></pre></td></tr></table></figure></li><li><p><strong>F.flash        网页图片视频专用插件</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@ yaourt -S flashplugin</span><br></pre></td></tr></table></figure></li><li><p><strong>G.ssh            密匙</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@ pacman -S openssh</span><br></pre></td></tr></table></figure></li><li><p><strong>H. gnome-tweak-tool    GNOME 管理设置</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@ pacman -S gnome-tweak-tool</span><br></pre></td></tr></table></figure></li><li><p><strong>I.screenfetch 可在终端输出计算机信息的软件</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@ pacman -S screenfetch</span><br><span class="line">运行</span><br><span class="line">root@ screenfetch</span><br><span class="line">自动运行 在 ～/bashrc 中加入单行的 screenfetch 即可</span><br><span class="line">下次打开终端将自动运行并输出。</span><br></pre></td></tr></table></figure></li><li><p><strong>J.gedit        文本编辑器</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@ pacman -S gedit</span><br><span class="line">vim 默认已经安装，如果没有执行</span><br><span class="line">root@ pacman -S vim</span><br></pre></td></tr></table></figure></li><li><p><strong>K.邮件</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@ pacman -S Thunderbird</span><br></pre></td></tr></table></figure></li><li><p><strong>L.图片编辑</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@ pacman -S gimp</span><br></pre></td></tr></table></figure></li><li><p><strong>L.WeChat</strong><br>对于以上所有软件，如果 pacman 下载失败，<br>则更新一下 # pacman -Syy 软件源后再试一下。<br>如果出现 pacman 找不到软件，则使用 yaourt -S 软件名 来安装</p></li></ul></li></ul><h2 id="美化系统"><a href="#美化系统" class="headerlink" title="美化系统"></a>美化系统</h2><p>需要美化三个地方，分别是 gnome、gdm、grub 的美化</p><h3 id="gnome"><a href="#gnome" class="headerlink" title="gnome"></a>gnome</h3><ul><li><p><strong>图表主题</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">num 图标主题</span><br><span class="line">root@ yaourt -S numix-circle-icon-theme-git</span><br><span class="line">paper 图标主题</span><br><span class="line">root@ yaourt -S paper-icon-theme-git</span><br></pre></td></tr></table></figure></li><li><p><strong>GTK 主题</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">arc 主题</span><br><span class="line">root@ yaourt -S gtk-theme-arc-git</span><br><span class="line">paper 主题</span><br><span class="line">root@ yaourt -S paper-gtk-theme-git</span><br></pre></td></tr></table></figure></li><li><p><strong>gnome-shell 主题</strong><br>Candy 主题<br>参照这里下载 <a href="http://www.linuxidc.com/Linux/2016-08/134383.htm" target="_blank" rel="noopener">http://www.linuxidc.com/Linux/2016-08/134383.htm</a><br>对于 Pper 主题参照这个地址 <a href="https://snwh.org/paper/download" target="_blank" rel="noopener">https://snwh.org/paper/download</a></p></li><li><strong>gnome 扩展</strong><blockquote><p>Auto move windows<br>Coverflow alt-tab            // alt+tab 是 3D 显示<br>Dash to dock                            // 配置工作条<br>Dynamic panel transparency        // 配置顶栏<br>Frippery move clock                // 顶部时间移到右边<br>Hide activities button            // 去掉右上角的活动按钮<br>Hide workspace thumbanails        //隐藏 Overview 视图右边的工作区栏<br>No topleft hot corner                // 禁止鼠标停靠左上角进入活动视图<br>Openweather                            // 顶栏显示天气预报<br>Pixel saver                            // 最大化隐藏标题栏<br>Remove dropdown arrows            // 去掉右上角的下拉箭头<br>Status itile bar                    // 实现顶部标题<br>Transparent top bar                // 透明顶栏<br>User themes                            // 要更换 shell 主题必须开启<br>Workspace indicator                //顶栏显示当前工作区号<br>Input method panel                 //輸入法面板 — 輸入法系統托盤</p></blockquote></li></ul><h3 id="一些设置"><a href="#一些设置" class="headerlink" title="一些设置"></a>一些设置</h3><ul><li><strong>1.gnome-tweak-tool 字体设置</strong><blockquote><p>   窗口标题：Cantarell Bold    11<br>   界面：Serif Regular            11<br>   文档：Sans Regular            11<br>   等宽：Monospace Regular    11</p></blockquote></li><li><p><strong>2. 窗口标题栏按钮重新排序或更改位置</strong></p><blockquote></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@ gsettings set org.gnome.desktop.wm.preferences button-layout &apos;:minimize,maximize,close&apos;</span><br></pre></td></tr></table></figure></li><li><blockquote><p>其中冒号表示按钮出现的位置</p></blockquote></li></ul><h3 id="gdm"><a href="#gdm" class="headerlink" title="gdm"></a>gdm</h3><ol><li><p>更改 GDM 壁纸</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">root@ cd ~</span><br><span class="line">root@ curl -L -O http://archibold.io/sh/archibold</span><br><span class="line">root@ chmod +x archibold</span><br><span class="line">root@ sudo mv archibold /usr/bin</span><br><span class="line">root@ archibold login-background /home/pic/a.jpg</span><br><span class="line">其中 /home/pic/a.jpg 为 背景图片的地址</span><br><span class="line">重启后登陆界面即变成你的壁纸了</span><br></pre></td></tr></table></figure></li><li><p>更改 GDM 主题</p></li><li>参考一下使用 gdm3setup 软件配置<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@ yaourt -S gdm3setup</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>其中包括了开启指纹等配置！</p></blockquote><h3 id="grub"><a href="#grub" class="headerlink" title="grub"></a>grub</h3><ol><li>更改 GRUB 背景图<blockquote><p>修改 /etc/default/grub    文件<br>将 #GRUB_THEME=”主题地址” 去掉注释号，并添加图片路径</p></blockquote></li><li>更改 GRUB 主题<blockquote><p>主题一般放置在 /boot/grub/themes 下<br>修改 /etc/default/grub 文件<br>将 #GRUB——THEME=”/boot/grub/themes/主题包/theme.txt”<br>去掉注释，并添加主题包的 theme.txt 文件路径</p></blockquote></li><li>更新GRUB<br>root@ grub-mkconfig -o /boot/grub/grub.cfg</li></ol>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Arch-基础安装</title>
      <link href="/2017/05/28/%E5%AE%89%E8%A3%85%E8%BF%87%E7%A8%8B-Arch/"/>
      <url>/2017/05/28/%E5%AE%89%E8%A3%85%E8%BF%87%E7%A8%8B-Arch/</url>
      
        <content type="html"><![CDATA[<h2 id="Arch-Linux-安装记录"><a href="#Arch-Linux-安装记录" class="headerlink" title="Arch Linux 安装记录"></a><strong>Arch Linux 安装记录</strong></h2><ul><li><strong>读者必看</strong></li><li>如果你是第一次接触 ArchLinux，请务必看完这一段</li></ul><ol><li><p>我的系统信息：</p><blockquote><p>系统镜像版本：archlinux-2017.05.01-x86_64.iso<br>系统版本：x86_64 Linux 4.11.2.1<br>GNOME 版本：3.24.2</p></blockquote></li><li><p>分区: </p><blockquote><p>我没亲自尝试过，因此没有写上来。如果你是新手，请务必另外在网上搜索并准   备一篇分区方法的文章。</p></blockquote></li><li><p>网络:</p><blockquote><p> 在网络配置那一部分不详细，因为我是路由器分的有线网络。<br>如果你是新手，请务必另外网上&gt; 搜索网络配置。例如 wifi 配置方法的文章。</p></blockquote></li><li><p>本教程过长，因此分两卷：</p><blockquote><p>上卷主要讲解 安装前的装备 到 安装后的系统设置<br>下卷则主要讲解用户环境配置，对于高手可以忽略下卷，但也不一定可以找到你需要的东西。</p></blockquote></li><li><p>在完成安装基本系统后的设置总体分为两部分：系统设置、用户环境配置</p><blockquote><p>系统设置 – 是在安装完系统之后重启之前必须要做的设置，否则后果很麻烦。<br>用户环境配置 – 是安装完系统并重启之后可按自己的意愿进行配置。</p></blockquote></li><li>声明:<blockquote><ol><li>以下所有操作，都是作者亲自操作而写下的，一般只要系统版本差别不大，应该没什么问题的。</li><li>新手按此教程流程操作则可以成功安装完整个用户系统。但事情没有绝对，如有问题，欢迎发送邮件。</li><li>欠缺的网络配置和分区方法，待以后有亲自操作后再更新本文章，对此表示抱歉<blockquote><p>参考: <a href="https://wiki.archlinux.org/index.php/Network_configuration#Device_driver" target="_blank" rel="noopener">网络配置</a></p></blockquote></li><li>对于 U盘 无法启动，推荐使用: Linux dd 命令、Windows Rufus 软件<blockquote><p>参考：<a href="https://wiki.archlinux.org/index.php/USB_flash_installation_media" target="_blank" rel="noopener">官方</a></p></blockquote></li></ol></blockquote></li></ol><ul><li><strong>下载 Arch</strong><blockquote></blockquote>官方教程：<br>浏览器地址栏输入 <a href="https://archlinux.org" target="_blank" rel="noopener">https://archlinux.org</a><br>网页右上角单击 Downcload<br>在新页面开头找到 Installation Guide 点击进入<br>下拉网页，在右边选择   中文简体 即可开始阅读<blockquote></blockquote></li></ul><h3 id="一、安装之前的配置"><a href="#一、安装之前的配置" class="headerlink" title="一、安装之前的配置"></a><strong>一、安装之前的配置</strong></h3><blockquote></blockquote><p>注意：<br>这里的配置都必须是立即生效的，因为这部分的所有操作都是针对 u盘的，重启后则失效！<br>所以别指望做什么设置然后重启u盘系统后会生效！</p><blockquote></blockquote><ul><li><p><strong>1  键盘布局（默认 us，是二位的字母编码表，中国为 cn）可忽略</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@ loadkeys us</span><br></pre></td></tr></table></figure></li><li><p><strong>2 连接网络</strong><br>测试网络连接是否正常</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@ ping -C 3 archlinux.org</span><br></pre></td></tr></table></figure><ul><li><p><strong>A. 有线配置（默认已启动模块并自动连接，如果没有输入以下命令</strong><br><a href="https://wiki.archlinux.org/index.php/Network_configuration#Device_driver" target="_blank" rel="noopener">参考官方</a></p></li><li><p><strong>B. 无线配置</strong><br><a href="https://wiki.archlinux.org/index.php/Wireless_network_configuration" target="_blank" rel="noopener">参考官方</a></p></li></ul></li></ul><blockquote></blockquote><ul><li><p><strong>2 更新系统时间</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@ timedatectl set-ntp-true// 开启 systemd-timesyncd 时间服务</span><br><span class="line">root@ timedatectl status // 确认时间是否正确</span><br></pre></td></tr></table></figure></li><li><p><strong>3 判断启动模式</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@ ls /sys/firmware/efi/efivars</span><br></pre></td></tr></table></figure></li></ul><blockquote></blockquote><p>如果提示没有该目录(Not The Directory) 类似字样，则系统以 BIOS 摸索启动<br>反之为 EFI 模式启动<br>这对于后面分区和安装 GUIB 有帮助</p><blockquote></blockquote><h3 id="二、安装之前的准备"><a href="#二、安装之前的准备" class="headerlink" title="二、安装之前的准备"></a>二、安装之前的准备</h3><ul><li><strong>1. 查看硬盘浏览分区情况</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">root@ fsdisk -l</span><br><span class="line">或者</span><br><span class="line">root@ lsblk -l</span><br><span class="line">如果你有多块硬盘</span><br><span class="line">root@ lsblk -l /dev/sda// 只查看 /dev/sda 这块硬盘的分区情况</span><br><span class="line">如果你希望看到分区的详细信息(可作为后面挂载分区时查看分区是否正常被挂载)</span><br><span class="line">root@ lsblk /dev/sda -o NAME,FSTYPE,SIZE,MOUNTPOINT</span><br><span class="line">这将包括分区的 名称、文件系统、大小、挂载点</span><br></pre></td></tr></table></figure></li></ul><blockquote></blockquote><ul><li><strong>说明：</strong></li><li><strong>在这里，你要确定好要进行操作的硬盘(如果你也有多块硬盘的话)和分区。</strong><blockquote></blockquote></li></ul><ul><li><strong>2 开始分区</strong><br>我事先已经分好了四个区，分别是 <blockquote></blockquote>/dev/sda1     boot     1G                (主分区)<br>/dev/sda2     /         50G            (主分区)<br>/dev/sda3     swap     4G                (主分区)<br>/dev/sda4    /home    剩余所有空间    (逻辑分区)<blockquote></blockquote></li><li><strong>其他参考官方教程，或在以后我有亲历再更新</strong></li><li><p><strong>3 格式化分区</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@ mkfs.ext2 /dev/sda1(格式化我的 boot 分区 /dev/sda1)</span><br><span class="line">root@ mkfs.ext4 /dev/sda2(格式化我的 root 分区/dev/sda2)</span><br><span class="line">root@ mkfs.ext4 /dev/sda4(格式化我的 home 分区/dev/sda4)</span><br><span class="line">root@ mkswap /dev/sda3(格式化我的 swap 分区/dev/sda3)</span><br></pre></td></tr></table></figure></li><li><p><strong>4 挂载分区</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">root@ swapon /dev/sda3// 先激活 swap 分区</span><br><span class="line">root@ mount /dev/sda2 /mnt// 先挂载 / 分区到 /mnt</span><br><span class="line">root@ mkdir /mnt/root// 创建 boot 文件夹</span><br><span class="line">root@ mkdir /mnt/home// 创建 home 文件夹</span><br><span class="line">root@ mount /dev/sda1 /mnt/boot// 挂载 boot 分区到 /mnt/boot</span><br><span class="line">root@ mount /dev/sda4 /mnt/home// 挂载 home 分区到 /mnt/home</span><br></pre></td></tr></table></figure></li></ul><blockquote></blockquote><p>说明：<br>如果你跟我一样独立出几个分区，则无论如何要先挂载根分区，再挂载其他分区<br>如果的所有目录都在一个分区里，则只需要挂载根分区就可以了<br>在挂载多个分区的时候，应该先挂载根分区后再创建要挂载其他分区的文件夹<br>只有挂载根分区后在 /mnt 下创建的文件夹才保存在根分区里面</p><blockquote></blockquote><ul><li><p><strong>5 选择原(这一步同样很重要)</strong></p><blockquote></blockquote><p>官方：<br>按照官方提示要编辑 /etc/pacman.d/mirrorlist 文件<br>把要启用的源取消注释，并放到最前面<br>我：<br>打开 /etc/pacman.d/mirrorlist 文件后<br>发现所有源已全部被启用，经过多次测试后且安装成功的方法如下</p><blockquote></blockquote></li><li><p><strong>安速度排序所有源：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@ cd /etc/pacman.d// 进入 pacman.d 文件夹</span><br><span class="line">root@ cp mirrorlist mirrorlist.backup // 备份出一个源文件</span><br><span class="line">root@ rankmirrors -n 6 mirrorlist.backup &gt; mirrorlist</span><br></pre></td></tr></table></figure></li></ul><p>对 mirrorlist.backup 文件进行安速度排序，并选择 6 个最快的源<br>复制到 mirrorlist。<br>稍等一会儿按下 ctrl + C 即可</p><blockquote></blockquote><ul><li><strong>注意：</strong><br>此操作会删除 mirrorlist 文件的内容，并写入新的内容。<br>但 mirrorlist.backup 文件不会改变，由于该文件被保存在 u 盘下的目录<br>因此 u盘断电，或是重启后该文件就不存在了。<br>另外，这里所指定的源在安装完后也一起被复制到新的系统下。<br>在执行上面命令后会出现一个光标不停的闪，不用理会，<br>系统正在一个一个源的测试。稍微等几分钟，按下 ctrl+c 结束进程</li><li><strong>说明：</strong><br>如果你选择的源地址是过时的，则系统会无法完全安装，即可能欠缺一些软件<br>如果你选择的源地址速度过慢，则整个系统安装过程可能持续太久<br>且软件下载也肯能不全<blockquote></blockquote><h3 id="三、开始安装基本系统"><a href="#三、开始安装基本系统" class="headerlink" title="三、开始安装基本系统"></a>三、开始安装基本系统</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@ pacstrap /mnt base // 安装 base 包组，即一系列需要的软件包的总称</span><br></pre></td></tr></table></figure></li></ul><p>耐心等待，没出错的情况下安装成功。<br>如有出错，请检查分区挂载是否正确以及重新更改源，再执行该操作<br>如此重复之，成功安装则忽略。</p><h3 id="四、安装之后的一些基础配置"><a href="#四、安装之后的一些基础配置" class="headerlink" title="四、安装之后的一些基础配置"></a>四、安装之后的一些基础配置</h3><ul><li><p><strong>1 创建 Fstab 文件(管理开机自动挂载分区)</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@ genfstab -U /mnt &gt;&gt; /mnt/etc/fstab</span><br><span class="line">root@ cat /mnt/etc/fstab // 检查 fstab 文件是否正确</span><br></pre></td></tr></table></figure></li><li><p><strong>2 更改系统根目录使用 Chroot 软件</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@ arch-chroot /mnt</span><br></pre></td></tr></table></figure></li></ul><p>当安装好系统时，我们所在的目录位于 u 盘 中的系统<br>以上操作将切换根目录为新安装的系统。<br>接下来的所有设置，都是针对新系统进行配置</p><ul><li><strong>3 配置时区</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@ ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</span><br></pre></td></tr></table></figure></li></ul><p>时区设置为上海，从命令中可见，实际上就是对Shanghai 这个文件进行软连接</p><ul><li><p><strong>4 配置时间</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@ bwclock --systohc -utc// 时间设置为 UTC</span><br></pre></td></tr></table></figure></li><li><p><strong>5 配置系统本地化</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@ vim /etc/locale.gen// 编辑 locale.gen 文件，把要启用的格式取消注释即可,例如 zh_cn.UTF-8,建议启用 UTF8 的 编码</span><br><span class="line">root@ locale-gen// 生成本地化</span><br><span class="line">root@ echo LANG=en_US.UTF-8 &gt; etc/locale.conf // 设置要作为默认的格式。这里建议使用 en_US.UTF-8 格式，以免命令行出现乱码</span><br></pre></td></tr></table></figure></li><li><p><strong>6 键盘布局</strong><br>  默认即可</p></li><li><strong>7 设置主机名并更改 hosts 文件</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@ echo WORK &gt; /etc/hostname// WORK 是我的主机名，也可以之间编辑 /etc/hostname 文件进行修改</span><br><span class="line">root@ vim /etc/hosts// 将以下格式添加在 END 前面</span><br></pre></td></tr></table></figure></li></ul><blockquote><hr><h2 id="127-0-1-1-WORK-lcoaldomain-WORK"><a href="#127-0-1-1-WORK-lcoaldomain-WORK" class="headerlink" title="127.0.1.1  WORK.lcoaldomain  WORK"></a>127.0.1.1  WORK.lcoaldomain  WORK</h2></blockquote><ul><li><strong>8 配置网络</strong><br>刚安装完系统，默认网络已经被启用了，但重新开机后便没有了。<br>因此设置开机自动开启网络服务<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@systemctl enable dhcpcd// dhcpcd 是一个守护进程，用于探测有线设备</span><br></pre></td></tr></table></figure></li></ul><p>如果还是不行，请<a href="https://wiki.archlinux.org/index.php/Network_configuration#Device_driver" target="_blank" rel="noopener">参考官网</a><br>关于无线，请<a href="https://wiki.archlinux.org/index.php/Wireless_network_configuration" target="_blank" rel="noopener">参考官网</a></p><ul><li><p><strong>9 设置 root 密码</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@ passwd // 输入两次密码回车键结束</span><br></pre></td></tr></table></figure></li><li><p><strong>10 安装引导GRUB</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@ pacman -S grub// 下载安装 GRUB2</span><br><span class="line">root@ grub-install --target=i286-pc /dev/sda// 安装 grub 引导</span><br><span class="line">root@ pacman -S os-prober// 安装该软件包可检测出其他系统</span><br><span class="line">root@ grub-mkconfig -o /boot/grub/grub.cfg// 更新GRUB设置并生成配置文件</span><br></pre></td></tr></table></figure></li><li><p><strong>10 处理后事以及重启</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@ exit // 退出当前系统，回到 u 盘系统</span><br><span class="line">root@ umount -R /mnt // 卸载已被挂载的分区，即新系统</span><br><span class="line">root@ reboot// 重启</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>yum 包管理器</title>
      <link href="/2016/11/16/package/"/>
      <url>/2016/11/16/package/</url>
      
        <content type="html"><![CDATA[<h2 id="yum-包管理"><a href="#yum-包管理" class="headerlink" title="yum 包管理"></a><strong>yum 包管理</strong></h2><blockquote><p>提示:</p><ul><li><strong>使用包管理时，为避免安装或升级过程中出现权限问题，应使用 su 命令切换到 root 用户</strong></li><li><strong>而 exit 命令则可以注销该账户</strong></li></ul></blockquote><blockquote><p>特性:</p><ul><li><strong>yum 会自动对软件包的依赖性进行检查</strong></li><li><strong>其检查结果是: 除软件包之外，还需要哪些依赖包，或应该升级那些软件包来解决依赖性问题</strong></li></ul></blockquote><ul><li><p><strong>yum 在线安装</strong></p><blockquote><p><pre><br><strong> yum install [软件名称] </strong><br><code></code></pre></p><ul><li><strong>其软件包对应格式为 .rpm 文件</strong></li><li><strong>它会从指定的服务器(软件源/仓库)上下载对应的 rpm 软件包(只要该软件存在)</strong></li></ul></blockquote></li><li><p><strong>yum 本地安装</strong></p><blockquote><p><pre><br><strong> yum localinstall [软件名称] </strong><br><code></code></pre></p><ul><li><strong>它会自动在当前目录或指定的目录下寻找对应名字的 rpm 软件包进行安装</strong></li><li><strong>如果遇到提示没有签名的软件，–nogpgcheck 可以忽略这个问题进行安装</strong><br><pre><br><strong> yum localinstall [软件名称] –nogpgcheck </strong><br><code></code></pre></li></ul></blockquote></li><li><p><strong>yum 源码安装</strong></p><blockquote><p>基本步骤:</p><ol><li><strong>下载源码</strong></li><li><strong>解压源码到 /usr/local/src 目录下，也可以是别的目录，前者是系统常用软件安装的目录</strong></li><li><strong>进入解压后得到的软件包目录</strong></li></ol><ul><li><strong>查看 INSTALL 文档 和 README 然后遵循文档中的介绍进行安装</strong></li><li><strong>如果没有以上两个文档，则遵循一下命令进行安装</strong><br><strong>运行配置文件，对软件进行配置</strong><br><pre><br>./configure –prefix=软件名称<br><code><br><strong>编译软件源代码</strong><br><pre><br>make<br><code><br><strong>安装软件</strong><br><pre><br>make install<br><code> </code></pre></code></pre></code></pre></li></ul><ol start="4"><li><strong>如果安装过程中出现问题，根据提示信息用 yum search 查找依赖包 并 yum install 安装依赖包</strong></li></ol></blockquote></li></ul><blockquote><p>本文永久连接: <a href="http://www.guib.in" target="_blank" rel="noopener">http://www.guib.in</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>C++ 变量是什么</title>
      <link href="/2016/11/09/%E5%8F%98%E9%87%8F-C++/"/>
      <url>/2016/11/09/%E5%8F%98%E9%87%8F-C++/</url>
      
        <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a><strong>概念</strong></h2><blockquote></blockquote><ul><li><strong>变量，是拥有一个名字且可以供程序操作的存储空间</strong></li><li><strong>变量的类型决定了它所占空间大小和布局方式，以及可以参与的运算</strong></li><li><strong>对 c++ 来说，变量和对象一般可以互换使用(即声明一个变量说成声明一个对象)</strong></li><li><strong>对象是指一块能存储数据并且具有某种类型的内存空间</strong></li></ul><h2 id="初始值"><a href="#初始值" class="headerlink" title="初始值"></a><strong>初始值</strong></h2><blockquote></blockquote><ul><li><strong>初始化不是赋值，其含义是在创建变量时(申请内存时)赋予它一个初始值</strong></li><li><strong>而赋值的含义是，把变量(或对象)当前值擦除，而以一个新值来代替</strong></li></ul><h2 id="列表初始化"><a href="#列表初始化" class="headerlink" title="列表初始化"></a><strong>列表初始化</strong></h2><blockquote><p><strong>特点，在使用列表初始化的同时，如果这个初值存在被丢弃信息的危险，则编译器会报错</strong><br> <pre><br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int sold = &#123;0&#125;;</span><br><span class="line">int sold &#123;0&#125;;</span><br><span class="line">int sold (0);</span><br></pre></td></tr></table></figure></pre></p></blockquote><blockquote></blockquote><p> 其中花括号被得到了全面应用<br> 这三条语句可以说等价于 int sold =0;<br> <code></code></p><h2 id="声明和定义之间的关系"><a href="#声明和定义之间的关系" class="headerlink" title="声明和定义之间的关系"></a><strong>声明和定义之间的关系</strong></h2><blockquote><p>C++ 支持分离式编译机制，即允许将程序分割为若干文件，每个文件可被独立编译<br> 因此，也提供在文件之间共享代码和变量的方法<br><code>以浅显的角度讲:</code></p><ul><li><strong>声明，是让程序知道有该名字的一个变量</strong></li><li><strong>一个文件如果想使用另一个文件中的变量，则必须包含(include)那个名字的声明</strong></li><li><strong>定义，是负责创建与名字关联的实体</strong></li></ul></blockquote><blockquote><p><code> 以变量的角度讲:</code></p><ul><li><strong>声明规定了变量的类型和名字</strong></li><li><strong>定义则会申请存储空间，同时还可能被副一个初始值</strong></li></ul></blockquote><blockquote><p><code> 一般情况下，当在声明变量的同时也被定义<br><code> 如果只想声明而非定义它(即不创建内存空间)时，应使用 extern 且不能显式初始化变量</code></code></p></blockquote><p> <pre><br> 例:<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">extern int i; 只声明 i 这个名字，然而并不为它创建内存空间</span><br><span class="line">int i; 声明 i 这个名字并创建内存空间，其值如果未被初始化，则是垃圾值</span><br></pre></td></tr></table></figure></pre></p><blockquote></blockquote><p> <code></code></p><blockquote><ul><li><code> 如果包含了初始化的 extern 声明则会产生抵消作用变成定义</code></li><li><code> 函数体内部如果声明一个 extern 变量将会引发错误</code></li><li><code> 变量只能被定义一次(即只能在一个地方创建内存空间)</code></li><li><code> 但变量可以被多次且不同地方声明，要避免重复定义</code></li><li><code> 在多文件中，变量只能在一个文件中出现定义，<br>而其他用到该变量的文件必须包含它的声明才可使用</code></li></ul></blockquote><blockquote><p>本文永久连接: <a href="http://www.guib.in" target="_blank" rel="noopener">http://www.guib.in</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>C++ 基本数据类型</title>
      <link href="/2016/11/08/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-C++/"/>
      <url>/2016/11/08/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-C++/</url>
      
        <content type="html"><![CDATA[<h2 id="长度或尺寸"><a href="#长度或尺寸" class="headerlink" title="长度或尺寸"></a><strong>长度或尺寸</strong></h2><p>在内存中，数据非 0 即 1 ，可被寻址的最小内存块称为字节，即以字节来寻址。<br>而存储的基本单元则称为字，通常由几个字节组成。</p><ul><li><p><strong>字符型</strong></p><blockquote><p>算术类型: <strong> 即该类型数据所占用的位数，然而在不同机器上却有所差别 </strong><br>算术类型:  <strong> 分为 整形（字符型、布尔型）、浮点型 </strong></p></blockquote><p><pre><br><strong> char      </strong> 占用一个字节（8 位）<br><strong> wchar_t   </strong> 占用 2 个字节 （16 位）<br><strong> char16_t  </strong> 占用 2 个字节（16 位）<br><strong> char_32_t </strong> 占用 4 个字节（32 位）<br><code></code></pre></p><blockquote><p>其中 <strong> chat16_t </strong> 和 <strong>chat32_t </strong> 为 <strong> Unicode </strong> 字符集类型<br><strong>wchat_t </strong> 用于确保可以存储机器最大扩展字符集中的任意字符</p></blockquote></li><li><p><strong>整数型</strong></p><blockquote><p><strong>c++ 标准规定</strong></p></blockquote><p><pre><br><strong> int </strong> 至少和 <strong> short </strong> 一样大 (即 <strong> int </strong> 最小只能是 占用两个字节)<br><strong> long </strong> 至少和 <strong> int </strong> 一样大  (即 <strong>long </strong> 最小只能是 <strong> int </strong> 的尺寸 4 字节)<br><strong> long long </strong> 至少和 <strong> long </strong> 一样大</pre></p><blockquote><p><code></code></p></blockquote></li><li><p><strong>浮点型</strong> </p><blockquote><p><strong>分为 单精度 和 双精度</strong><br>通常：</p></blockquote><p><pre><br><strong> float </strong> 以一个字（32字节）来表示一个数，7 个有效位<br><strong> double </strong> 以两个字 (64字节) 来表示一个数，16 个有效位<br><strong> long double </strong> 以 四个字 (96/128字节) 来表示一个数 ， 一般用于特殊需求，视硬件实现精度不同位数不同<br><code></code></pre></p></li></ul><h2 id="修饰类型"><a href="#修饰类型" class="headerlink" title="修饰类型"></a><strong>修饰类型</strong></h2><ul><li><p><strong>带符号 (signed) 和无符号 (unsigned)</strong></p><blockquote></blockquote><p><pre><br>带符号的类型可表示正数、负数 和 0， 无符号类型则仅能表示大于等于 0 的直<br>所有整形一般被默认为带符号的类型<br>而由 unsigned 修饰的类型则为无符号类型<br><code></code></pre></p><blockquote></blockquote><p><pre><br>字符型被分为三种：char、signed char、unsigned char<br>但字符的表现形式只有两种方式，即 带符号字符、和 无符号字符<br>而 char 不是带符号类型 就是无符号类型， 具体由编译器决定<br><code></code></pre></p><blockquote></blockquote></li><li><p><strong>字面值常量</strong></p><blockquote></blockquote><p><pre><br>以 0 开头的整数表示为 8 进制<br>以 0x 或 0X 开头的整数表示为 16 进制<br>整数则直接表示</pre></p><blockquote><p><code><br><strong>默认情况下</strong></code></p></blockquote><p><pre><br>十进制字面值是代符号数，其类型是 int、long、和 long long 中最小的那个<br>八进制和十六进制字面值的类型是能容纳其数值的 int 、unsigned int、long、unsigned long<br>long long、unsigned long long 中最小的那个<br>short 没有对应的字面值</pre></p><blockquote><p><code></code></p></blockquote><blockquote><p><strong>字面值带前缀</strong></p></blockquote><p><pre><br>L    代表类型为宽字符型(wchat_t) 字面值<br>u8   代表类型为 utf-8 (utf-8 用 8 位编码一个 unicode 字符)字面值<br>u    代表类型为 char16_t (用 16 位编码一个 unicode 字符)字面值<br>U    代表类型为 char32_t (用 32 位编码一个 unicode 字符)字面值<br><code></code></pre></p><blockquote><p><strong>字面值带后缀</strong></p></blockquote><p><pre><br>u / U    代表类型为无符号类型(unsigned)<br>l / L    代表类型为长整型类型(long/long double)<br>ll / LL  代表类型为长长型类型(long long)<br>f  / F   代表类型为浮点型类型(float)<br><code> </code></pre></p><blockquote><p><strong>其他</strong></p></blockquote><p><pre><br>true / false 是 bool 类型的字面值<br>nullptr 是 c++ 指针字面值<br>NULL 是 c 指针字面值<br><code></code></pre></p></li><li><p><strong>类型选择</strong></p><blockquote></blockquote><p><pre><br>1 当明确知道数值不可能为 负时，选用无符号类型<br>2 一般使用 int 来执行整数运算，如果数值超过该类型表示范围可选用 long long<br>  通常，short 显得太小，而 long == int<br>3 算术表达式中不要使用 char 和 bool，只有在存放字符或布尔值时才使用它们<br>   因 chat 在不同机器上不是符号就是无符号，如果因为需要的数值不大而使用char，<br>   则因明确指定为 signed 或 unsigned<br>4 执行浮点数运算时选用 double， 因为 float 通常精度不够，而双精度和单精度计算代价差别不大，<br>  有些机器上甚至要快于单精度，而 long double 一般别用，其运行的消耗也不容忽视。<br><code></code></pre></p><blockquote></blockquote></li><li><p><strong>类型转换</strong></p><blockquote></blockquote><p>类型所能代表的值的范围决定了转换的过程<br><pre><br>1 当把一个非 bool 类型的值赋予 bool 类型变量时，当该值为 0 时 false ，否则为 true<br>2 当把一个 bool 值赋予 非 bool 类型的变量时，该值为 false 时为 0， 否则为 1<br>3 当把一个浮点数赋予整数类型时，进行了近视处理，其结果只保留小数点之前的部分<br>4 当把一个整数值赋予浮点类型时，小数部分被记为0， 如果该整数所占空间超过了浮点型的容量，精度可能有损失<br>5 当赋予无符号类型一个超出表示范围的数值时， 结果是原值对无符号类型可表示的最大值进行取模后的余数<br>6 当赋予带符号类型一个超出表示范围的数值时，结果时未定以的<br>  程序可能继续工作，可能崩溃，也可能生成垃圾数据<br><code></code></pre></p><blockquote></blockquote></li><li><strong>转义序列</strong><blockquote></blockquote>有两类字符程序员不能直接使用<br><pre><br>1 不可打印的字符！如退格或其他没有可视的图符<br>2 特殊含义的字符！如单引号、双引号、问号、反斜杠等<br><code><blockquote></blockquote>可以有两种方式来完成以上这些字符<br><pre><br>1 转义序列，如 \n ，而 \tHi!! 则输出制表符和 Hi!!<br>2 泛化转义序列，\ 后跟一个或多个十六进制或八进制值，如 \12 则是换行符，<br>  而 \x1234 则是16进制数对应的符号<br><code></code></pre></code></pre></li></ul><blockquote><p>本文永久连接: <a href="http://www.guib.in" target="_blank" rel="noopener">http://www.guib.in</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>hexo 管理博客</title>
      <link href="/2016/08/16/git+hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2-C/"/>
      <url>/2016/08/16/git+hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2-C/</url>
      
        <content type="html"><![CDATA[<h2 id="hexo-初级使用"><a href="#hexo-初级使用" class="headerlink" title="hexo 初级使用"></a>hexo 初级使用</h2><h3 id="如果你要新发表一篇文章"><a href="#如果你要新发表一篇文章" class="headerlink" title="如果你要新发表一篇文章"></a>如果你要新发表一篇文章</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"文章名"</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>会在 source/_posts 目录下新建一个文件，即：你的仓库/source/_posts/文章名</p><p>现在，你可用 gedit 打开编辑。你也可以使用 Makrdown 带有语法的编辑<br>关于 Markdown 的使用方法可以参考：<a href="http://www.pchou.info/open-source/2014/07/07/something-about-markdown.html" target="_blank" rel="noopener">http://www.pchou.info/open-source/2014/07/07/something-about-markdown.html</a></p><p>假设你使用 gedit 打开编辑：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">title: <span class="comment"># 是你的标题</span></span><br><span class="line">date: <span class="comment"># 是创建文件的日期，其实也是发表文章的日期</span></span><br><span class="line">tags: <span class="comment"># 是文章的标签</span></span><br></pre></td></tr></table></figure></p><p>需要注意的是冒号： 后面必须带一个空格。后面的也是一样，大家注意。<br>除此之外还可以在里面添加字段。那个网页我找不到了，所以你们自己谷歌或者百度把。</p><h3 id="如果你要向博客更新这篇文章："><a href="#如果你要向博客更新这篇文章：" class="headerlink" title="如果你要向博客更新这篇文章："></a>如果你要向博客更新这篇文章：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean<span class="comment">#清除缓冲</span></span><br><span class="line">$ hexo g<span class="comment">#生成 html 文件</span></span><br><span class="line">$ hexo d<span class="comment">#向网站提交文件，或者说是更新吧！</span></span><br></pre></td></tr></table></figure><p>每当你更改了什么设置，更新添加或删除文章，都要用到这些命令。<br>然后你的改变才会应用上去，按照大家惯用的说法，叫做 清除，部署和提交。</p><h3 id="如果你希望先在本地调试而不直接发表："><a href="#如果你希望先在本地调试而不直接发表：" class="headerlink" title="如果你希望先在本地调试而不直接发表："></a>如果你希望先在本地调试而不直接发表：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server <span class="comment"># 本地调试</span></span><br></pre></td></tr></table></figure><h3 id="如果你想从博客本地或者网络删除一篇文章："><a href="#如果你想从博客本地或者网络删除一篇文章：" class="headerlink" title="如果你想从博客本地或者网络删除一篇文章："></a>如果你想从博客本地或者网络删除一篇文章：</h3><h4 id="如果你想仅仅删除本地文章而不影响博客"><a href="#如果你想仅仅删除本地文章而不影响博客" class="headerlink" title="如果你想仅仅删除本地文章而不影响博客"></a>如果你想仅仅删除本地文章而不影响博客</h4><p>其方法是在 仓库/source/_posts/ 目录下载选择你的文章删除。<br>或者：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rm 仓库/<span class="built_in">source</span>/_posts/文章名</span><br></pre></td></tr></table></figure></p><p>但下次重新部署时对应博文将被删除</p><h4 id="如果你想从博客里删除一篇文章"><a href="#如果你想从博客里删除一篇文章" class="headerlink" title="如果你想从博客里删除一篇文章"></a>如果你想从博客里删除一篇文章</h4><p>在博文删除后再执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean</span><br><span class="line">$ hexo generate</span><br><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>重新部署过后博客将被更新。</p><h2 id="hexo-美化"><a href="#hexo-美化" class="headerlink" title="hexo 美化"></a>hexo 美化</h2><p>无非就是主题版面！<br>如果你会 html 或者 php 和 cs 等基础。你完全可以自己定制。<br>没有这方面基础的请往下看</p><h3 id="更换博客版面主题"><a href="#更换博客版面主题" class="headerlink" title="更换博客版面主题"></a>更换博客版面主题</h3><p>你需要找一款主题：这可以在 hexo 官网找，或者你可以可以参看这里推荐的几款主题。<br>网址在这：<a href="http://www.jianshu.com/p/465830080ea9#" target="_blank" rel="noopener">http://www.jianshu.com/p/465830080ea9#</a><br>两种方法：<br>1 自己下载主题，然后解压到 仓库/themes 目录下，没有就新建 themes<br>2 命令<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> 仓库<span class="comment"># 切换路径到你仓库根目录下</span></span><br><span class="line">$ git <span class="built_in">clone</span> 主题地址 themes/主题名称 <span class="comment">#下载主题</span></span><br></pre></td></tr></table></figure></p><p>下载完后<br>如果原先没有 themes 则会在 仓库目录下多出一个 thems 文件夹，你的主题就放在里面<br>然后在当前目录下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thems: 主题名<span class="comment">#启用主题</span></span><br></pre></td></tr></table></figure><p>如果你想在本地验证一下主题</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean <span class="comment"># 验证之前最好清一下 hexo 的缓存。这是参照别人教程说的。</span></span><br><span class="line">$ hexo s --debug<span class="comment"># 如果一切正常，将输出本地网址</span></span><br></pre></td></tr></table></figure><p>在浏览器输入网址即可查看。<br>最后将新主题发布出去</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean</span><br><span class="line">$ hexo generate</span><br><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><h2 id="博客管理页面"><a href="#博客管理页面" class="headerlink" title="博客管理页面"></a>博客管理页面</h2><p>要更改博客页面的一些设置，其实也很简单，<br>对于 高手可忽略本段内容。<br>hexo 主题有两个 _config.yml 文件<br>第一个在 仓库 目录下，仓库/_config.yml         # 称为全局配置文件，主要是运行方面的<br>第二个在 仓库/themes/你的主题名/_config.yml # 称为局部配置文件，主要是个性化方面<br>而在 仓库/themes/你的主题名/language/ 目录下的文件是语言包！<br>现在我只说一些基本配置，更多详细可以参看网址，等我打完文章提供给你！</p><h3 id="全局配置文件，即-仓库目录下的-config-yml"><a href="#全局配置文件，即-仓库目录下的-config-yml" class="headerlink" title="全局配置文件，即 仓库目录下的 _config.yml"></a>全局配置文件，即 仓库目录下的 _config.yml</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">title: <span class="comment">#站点名</span></span><br><span class="line">subtitle: <span class="comment">#副标题</span></span><br><span class="line">description:  <span class="comment">#对站点的描述</span></span><br><span class="line">author: <span class="comment">#作者，默认在站点左下角可以看到</span></span><br><span class="line">language: <span class="comment">#语言包设置, 中文默认为 zh_Hans 包</span></span><br><span class="line">timezone: <span class="comment"># 时区，没什么特别需要别乱该，不然会造成乱码</span></span><br><span class="line">url:<span class="comment"># 如果你自己有域名可以进行更改</span></span><br><span class="line">theme:<span class="comment"># 使用的主题，下载主题后也可以直接打开该文件修改这里主题名。</span></span><br><span class="line"><span class="built_in">type</span>:<span class="comment"># 类型，一般为 git</span></span><br><span class="line">repo:<span class="comment"># 一般 git@github.com:仓库名/仓库名.git，这是你的网络仓库</span></span><br><span class="line">branch:<span class="comment"># 分支，一般填写默认分支 master，即主分支</span></span><br><span class="line">message:<span class="comment"># 不知道干嘛的，其英文翻译是 信息，消息的意思。</span></span><br></pre></td></tr></table></figure><p>我只列出一部分字段，列出来的说明可以随意更改，<br>没有列出来的，如果你不懂，就别乱该，要乱该那么先备份，否则很麻烦。<br>如果你的主题默认是显示英文，则在 language 字段修改为中文包。<br>修改为中文包后如果显示的中文名字不喜好，则在<br>仓库/themes/你的主题/language/ 目录下找到 Zh_Hans 中文包文件，修改文字。<br>当然别忘了修改后调试 和 部署提交的命令。这里就不重复这些命令了，上面有。<br>如果你要修改头像，则在该文件里任意位置添加一个字段 avater</p><p>例如<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Site</span></span><br><span class="line">title: 站点名</span><br><span class="line">subtitle: 副标题</span><br><span class="line">description:  没有描述</span><br><span class="line">author: 作者是我</span><br><span class="line">language: zh-Hans <span class="comment">#语言包设置</span></span><br><span class="line">timezone: <span class="comment">#时区</span></span><br><span class="line"><span class="comment"># 头像</span></span><br><span class="line">avatar: 网络图片地址</span><br></pre></td></tr></table></figure></p><p>在avater 字段冒号后面添加图片网址或者图片本地路径。<br>如果你添加的是本地路径，那么你应该修改 仓库/themes/你的主题/souce/Image/下的 avater.jpg 文件，把你想更改的头像放进去替换掉 avater.jpg 文件。</p><p>最后要注意的一个是 所有冒号后面必须带一个空格。注意，下面就不重复了！</p><h3 id="局部配置文件，即-仓库-themes-你的主题-config-yml"><a href="#局部配置文件，即-仓库-themes-你的主题-config-yml" class="headerlink" title="局部配置文件，即 仓库/themes/你的主题/_config.yml"></a>局部配置文件，即 仓库/themes/你的主题/_config.yml</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">menu: <span class="comment">#开始的下面的字段字段 是你的导航，你可用 # 号来禁用或启用某个导航</span></span><br><span class="line">     <span class="comment">#其中一些导航可能没有页面，需要自己添加这个页面。其他东西不要改，</span></span><br><span class="line">     <span class="comment">#对于导航，你只能改 # 号。</span></span><br><span class="line">menu_icon: <span class="comment">#导航的图标</span></span><br><span class="line"><span class="built_in">enable</span>: <span class="literal">true</span> <span class="comment"># 如果你不想显示导航图标则改为 false</span></span><br><span class="line"><span class="comment">#keyMapsToMenuItemkey: # 还不知道是干嘛的。往下就是导航名对应的图标名称</span></span><br><span class="line">对于图标，没什么必要的话不建议更改。</span><br><span class="line">social_icons: <span class="comment"># 以下的字段是更改图标的颜色</span></span><br><span class="line">sidebar: <span class="comment"># 以下的字段是更改侧栏显示左边还是右边，只要改前面的 # 号就可以了。</span></span><br><span class="line">Schemes: <span class="comment"># 另外，你如果有这个字段，则下面是主题的款式，要选择款式修改 # 号就可以了</span></span><br></pre></td></tr></table></figure><p>除此之外，其他很多，还是不建议新手随便乱改！</p><p>差点忘了补充上，对于 Next 主题可参看：<br><a href="http://theme-next.iissnan.com/getting-started.html" target="_blank" rel="noopener">http://theme-next.iissnan.com/getting-started.html</a><br>非 Next 主题的可参考配置方案！</p><h2 id="关于-hexo-命令"><a href="#关于-hexo-命令" class="headerlink" title="关于 hexo 命令"></a>关于 hexo 命令</h2><p>hexo clean        # 清除 Hexo 缓存文件<br>hexo server        # 本地测试端口<br>hexo generate    # 生成静态页面<br>hexo deploy        # 提交至网络<br>hexo new “文章名”        #新建一个文章文件用于编辑<br>hexo new page “网页名”     #新建一个网页。<br>hexo new”postName”     #新建文章</p><p>如果你嫌上面的命令麻烦，那么：</p><p>hexo clean         =     hexo c<br>hexo server         =     hexo s<br>hexo generate     =     hexo g<br>hexo deploy         =     hexo d</p><p>如果你还嫌每次部署提交麻烦，那么：</p><p>hexo g -d    一个命令搞定。</p><p>其他更详细的命令请到官方或者 百度和谷歌找！</p><h2 id="hexo-高级使用"><a href="#hexo-高级使用" class="headerlink" title="hexo 高级使用"></a>hexo 高级使用</h2><h3 id="添加图片存储系统"><a href="#添加图片存储系统" class="headerlink" title="添加图片存储系统"></a>添加图片存储系统</h3><p>等待更新</p><h3 id="评论系统"><a href="#评论系统" class="headerlink" title="评论系统"></a>评论系统</h3><h3 id="百度统计"><a href="#百度统计" class="headerlink" title="百度统计"></a>百度统计</h3><p>评论系统和百度统计我没有使用<br>可以参看 ：<a href="http://www.jianshu.com/p/a4b74cc9ff28" target="_blank" rel="noopener">http://www.jianshu.com/p/a4b74cc9ff28</a><br>以后有弄再把教程补充在这里！<br>不过关于多说，你还可以参看下面这篇文章后再决定<br><a href="http://www.im286.net/thread-10015701-1-1.html" target="_blank" rel="noopener">http://www.im286.net/thread-10015701-1-1.html</a></p><h3 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h3><p>暂未更新</p><blockquote><p>本文永久连接: <a href="http://www.guib.in" target="_blank" rel="noopener">http://www.guib.in</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>hexo 搭建博客</title>
      <link href="/2016/08/15/git+hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2-A/"/>
      <url>/2016/08/15/git+hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2-A/</url>
      
        <content type="html"><![CDATA[<p>本次主要分为 <strong>注册</strong> 和 <strong>创建仓库</strong> 两个部分<br><strong>重要提示：</strong>因章节编排需要，所以部分重要内容放在最后，建议看完整篇文章再进行操作</p><h2 id="注册-Github-账户"><a href="#注册-Github-账户" class="headerlink" title="注册 Github 账户"></a>注册 Github 账户</h2><h4 id="1-进入网址-https-github-com-进行注册"><a href="#1-进入网址-https-github-com-进行注册" class="headerlink" title="1. 进入网址 https://github.com/  进行注册"></a>1. 进入网址 <a href="https://github.com/" target="_blank" rel="noopener">https://github.com/</a>  进行<a href="https://github.com/" target="_blank" rel="noopener">注册</a></h4><blockquote><p><strong>Github 首页面：</strong><br>Username 填入自己喜欢的用户名<br>Email        填入要绑定账号的邮箱<br>Password  输入用户密码用户密码<br>Sign up for Github  单击来进行注册</p></blockquote><blockquote><p><strong>Join Github 页面：</strong><br>点击下方的 Create an account 来创建账户<br>当你邮箱收到 Github 发来的邮件时即可关闭该页面</p></blockquote><h4 id="2-验证-Github-账户（邮箱）"><a href="#2-验证-Github-账户（邮箱）" class="headerlink" title="2.  验证 Github 账户（邮箱）"></a>2.  验证 Github 账户（邮箱）</h4><blockquote><p><strong>邮箱页面：</strong><br>打开绑定的邮箱查看 github 发送的邮件<br>并点击邮件提供的链接即可进行完成验证</p></blockquote><blockquote><p><strong>Learn Git and GitHub without any code 页面：</strong><br>该页面有两个选择：</p><ul><li>Read the guide（阅读指南）    </li><li>Start a project （启动仓库）</li></ul></blockquote><p>选择 Start a project 将自动带你进入创建仓库的页面</p><h2 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h2><blockquote><p><strong>仓库页面</strong></p><ul><li>Repository name 输入仓库名</li><li>Description 仓库说明可忽略</li><li>public 公开的免费的仓库</li><li>Private 私人的收费的仓库</li><li>要勾选  Installize this repository with a README ，则需要在 code 页面找到推送地址</li><li>不勾选  Installize this repository with a README ，则直接在 code 页面显示推送地址</li><li>关于许可证版权的默认即可！</li></ul></blockquote><p>最后单击 <strong>Create repository</strong> 来创建仓库<br>至此仓库创建完成！！！</p><p><strong>提示：</strong><br>仓库选择：看个人需要选择，一般 公开即可，这里以公开仓库为例<br>是否创建 <strong>Readme</strong> 文件：为了简化步骤这里我们不勾选创建 <strong>Readme</strong> 文件</p><p><strong>简单介绍：</strong><br><strong>仓库主页面：</strong>从左往右依次是  <code>code lssues Pull requests Projects Wiki Insights Settings</code> 菜单</p><ul><li>code ： 博客的内容以后将放在该页面下</li><li>Settings： 则是该仓库的一些设置选项</li></ul><p>请保留停留在 code 页面，把浏览器最小化 后面需要用到该页面提供的推送地址</p><p><strong>重要提示：</strong></p><ol><li>qq 邮箱注册可能会被拦截 — 解决的办法自己 Baidu</li><li>仓库名本身是随意的命名的</li></ol><ul><li>使用 Github 简短域名仓库名的格式：<strong>用户名/用户名.github.io</strong></li><li>使用购买的自定义域名：仓库的名字可随意</li></ul><blockquote><p>本文永久连接: <a href="http://www.ostensir.org">http://www.ostensir.org</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>hexo 搭建博客</title>
      <link href="/2016/08/15/git+hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2-B/"/>
      <url>/2016/08/15/git+hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2-B/</url>
      
        <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>本文使用以下工具来搭建博客：</p><ul><li>使用 Github 网站来存放博客数据</li><li>使用 Github Page 功能来提供 100M 存储空间</li><li>使用 Git 工具来提交博客数据</li><li>使用 Node.js 来生成静态网页</li><li>使用 Hexo 工具来管理博客<br>本次搭建所使用的桌面环境： Manjaro 17 Gnome 3<a id="more"></a></li></ul><p>依赖关系：</p><ul><li>hexo 依赖 nodejs 来生成网页代码</li><li>hexo 依赖 git 来发布网站</li><li>git 与 github 配合来进行版本控制和通信</li></ul><h1 id="安装必要软件"><a href="#安装必要软件" class="headerlink" title="安装必要软件"></a>安装必要软件</h1><ol><li><p><strong>Git 安装:</strong><br><code>$ sudo pacman -S git</code></p></li><li><p><strong>Nodejs 安装:</strong>    </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">bash $ sudo pacman -S nodejs npm</span><br><span class="line">```    </span><br><span class="line">为了确保 npm 能正常安装插件需检查是否已安装 gcc     </span><br><span class="line">如果没有： `sudo pacman -S gcc make`    </span><br><span class="line">*********</span><br><span class="line">---</span><br><span class="line">3. **Hexo 安装:**   </span><br><span class="line">Hexo 已经被打包好了并存放于 AUR 仓库    </span><br><span class="line">因此我们可以从 AUR 安装 hexo 软件包    </span><br><span class="line">安装之前确保系统已经设置 AUR 源    </span><br><span class="line">我们可以使用 yaourt 来安装： `yaourt -S hexo-cli`</span><br><span class="line"></span><br><span class="line"># 本地搭建博客仓库</span><br><span class="line">说明：仓库 在系统本地实际上就是一个目录（文件夹）</span><br><span class="line">准备：    </span><br><span class="line">+ 想好一个位置用于放置自己的博客（e.g ~/）</span><br><span class="line">+ 想好一个名字用于命名自己的仓库（e.g blog）</span><br><span class="line"></span><br><span class="line">开始：    </span><br><span class="line">+ 创建博客本目录 `mkdir ~/blog`</span><br><span class="line">+ 进入博客根目录 `cd ~/blog`</span><br><span class="line">+ 初始化博客仓库 `hexo init`</span><br><span class="line">+ 安装博客组建包 `npm install`</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">``` bash</span><br><span class="line">$ hexo server# 然后在浏览器输入这里给出的网址即可访问</span><br></pre></td></tr></table></figure></li></ol><p>如有占用端口可执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server -p 5000 <span class="comment"># 改为其他端口</span></span><br></pre></td></tr></table></figure><p>本地搭建先到这里，但还没完！精彩还在后面</p><h2 id="注册-Github-帐号"><a href="#注册-Github-帐号" class="headerlink" title="注册 Github 帐号"></a>注册 Github 帐号</h2><p><a href="http://xbinhome.org/2016/08/15/access/" target="_blank" rel="noopener">注册帐号和创建远程仓库系列</a></p><h2 id="三、配置-SSH-公钥"><a href="#三、配置-SSH-公钥" class="headerlink" title="三、配置 SSH 公钥"></a>三、配置 SSH 公钥</h2><p>要让本地与远程 Github 网站建立联系，你还需要配置一下 ssh key 即 本地密匙<br>但这可能、或者、不是必须的，但有密匙能确保你通信提交文章不会被人加入一些东西。</p><h3 id="这里需要用到："><a href="#这里需要用到：" class="headerlink" title="这里需要用到："></a>这里需要用到：</h3><pre><code>你注册 Github 时的邮箱你的 Github 用户名准备一个你向远程博客更新文章时的密码（不是必须的）</code></pre><h3 id="条件："><a href="#条件：" class="headerlink" title="条件："></a>条件：</h3><pre><code>Ubuntu 系统下自动安装了 ssh ，你如果没有或者删了，需要安装上。关于 ssh key 安装方法 google ！</code></pre><h3 id="开始配置"><a href="#开始配置" class="headerlink" title="开始配置"></a>开始配置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> ~/.ssh<span class="comment">#切换到home主目录下的 .ssh 文件夹</span></span><br><span class="line">$ ssh-keygen -t rsa -C <span class="string">"邮箱地址"</span><span class="comment">#双引号不能省略喔，你省略了别说是我教你的。</span></span><br></pre></td></tr></table></figure><p>出现</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Enter passphrase (empty <span class="keyword">for</span> no passphrase): <span class="comment">#输入你想好的密码，你可以可以直接回车不配置。</span></span><br></pre></td></tr></table></figure><p>出现<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Enter same passphrase again: <span class="comment"># 要求你再输入一次密码，如果你上面回车，这里也是一起回车</span></span><br></pre></td></tr></table></figure></p><p>如果你两次都回车，在你提交文章到博客的时候，就不会要求输入密码。<br>关于密匙的用处我上面已经说了！看个人爱好了！<br>配置完后会出现一个美丽的方框，说明配置成功了</p><p>接下来请确保你文件管理器可以查看隐藏文件，没有可以 Ctrl + h 即可<br>然后进入 home 目录下 打开 .ssh 文件夹你会看到多出两个文件 id_rsa 和 id_rsa.pub<br>一个是 公用密匙，一个是 私用密匙。我们要用的是 id_rsa.pub 。<br>打开 id_rsa.pub 文件复制里面的全部内容，喜欢命令行的可用命令，cat 或 vim 。<br>打开浏览器登录到 Github 网站，<br>单击 settings（设置）-&gt; 单击左边的 Deploy keys （部署密匙）<br>这时会进入一个对话框。<br>把你复制的密匙粘贴到 key 框里，Title 不用管，要管页可以，我是随便填了。<br>然后单击 add key （加入密匙）</p><p>现在进行本地测试</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh -T git@github.com <span class="comment">#就这样，直接回车</span></span><br></pre></td></tr></table></figure><p>出现 提示要你输入 yes 和 no ，妈的我输入 y 不行，要 yes 这个注意了 然后回车<br>出现一个提示，如果末尾有一句 but GitHub not provide shell access. 说明添加密匙成功了</p><p>最后还有一个步骤，据说要配置用户名和邮箱，据说还可以是别的邮箱和随便起一个用户名。<br>但我用的是 Github 用户名和邮箱。你们自己尝试。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name <span class="string">"用户名"</span> <span class="comment"># 引号不能省</span></span><br><span class="line">$ git config --global user.email <span class="string">"邮箱"</span></span><br></pre></td></tr></table></figure><p>好了 SSH KEY 配置成功了！真是繁琐的一步！<br>网上一些旧的资料可以不用密匙，但不知道对于最新的 ubuntu 和 Github 是否管用就不知道了</p><h2 id="四、开始远程搭建"><a href="#四、开始远程搭建" class="headerlink" title="四、开始远程搭建"></a>四、开始远程搭建</h2><p>打开浏览器登录到 Github 在仓库管理页面左边蓝色按钮 clone or download 单击小三角形<br>然后会下拉一个框，单击在下拉框左上角的 Use SSH ，然后复制中间那条密匙连接。<br>ok ，回到本地，进入你创建的仓库文件夹目录下打开 _config.yml<br>修改或添加这几行内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  <span class="built_in">type</span>: git <span class="comment"># 类型为 git</span></span><br><span class="line">  repo:  <span class="comment">#粘贴你刚才复制的 类似于：git@github.com:用户名/仓库名.git</span></span><br><span class="line">  branch: master 分支</span><br><span class="line">  message: <span class="string">'站点更新：&#123;&#123;now&#125;(YYY-MM-DD HH:mm:ss)&#125;'</span>   我也不知道干嘛的，反正我是照弄了。</span><br></pre></td></tr></table></figure><p>type repo branch message 前面两个空格，： 后面一个空格 切记，出错将不能访问。</p><p>ok ，最后一个步骤</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save <span class="comment">#保存配置</span></span><br><span class="line">hexo clean <span class="comment">#删除缓存文件</span></span><br><span class="line">hexo generate <span class="comment">#建立 html 文件</span></span><br><span class="line">hexo deploy <span class="comment">#推送到网站</span></span><br></pre></td></tr></table></figure><p>浏览器输入 仓库名.github.io 能正常打开就 ok 了</p><blockquote><p>本文永久连接: <a href="http://www.guib.in" target="_blank" rel="noopener">http://www.guib.in</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
    </entry>
    
  
  
</search>
