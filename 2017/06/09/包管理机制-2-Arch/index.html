<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="Osten"><title>Arch 包管理器 | Osten Sir</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Arch 包管理器</h1><a id="logo" href="/.">Osten Sir</a><p class="description">www.ostensir.org</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Arch 包管理器</h1><div class="post-meta">Jun 9, 2017<span> | </span><span class="category"><a href="/categories/Linux/">Linux</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><a class="disqus-comment-count" href="/2017/06/09/包管理机制-2-Arch/#vcomment"><span class="valine-comment-count" data-xid="/2017/06/09/包管理机制-2-Arch/"></span><span> 条评论</span></a><div class="post-content"><p>上一章中，我们对源代码安装软件的过程做了一个总结<br>对 PKGBUILD 文件 和 makepkg 也有了些大概的了解<br>此外，我们还认识了 AUR 、ABS 、和 yaourt 工具。<br>今天让我们来详细了解究竟是如何从源代码安装软件的，<br>以及 PKGBUILD 文件这部分是核心内容，并带你深入的了解 pacman。<br>为了节省时间和字数，以下就不再重复上一章的内容了，直接讲重点内容。</p>
<h2 id="1-从源代码安装软件"><a href="#1-从源代码安装软件" class="headerlink" title="1. 从源代码安装软件"></a>1. 从源代码安装软件</h2><p>正常情况下，我们下载的源码包会包含以下几个文件：<br>README (读我)<br>INSTALL (安装)<br>COPYING (复件)<br>ChangeLog (更新日志)<br>configure(配置)</p>
<p><strong>README 文件:</strong><br>是源码包的说明文件，是对整个源码包的一个说明，类似于”安装前读我”。<br>例如: 它会告诉你这是一个什么软件，有哪些功能，能干嘛什么，要安装需要读哪个文件等。<br><strong>INSTALL 文件:</strong><br>它会告诉你要怎样安装这个软件，有时还会如何添加插件或干净的安装的方法。<br>例如: 它可能会告诉你要先执行什么操作再执行哪些操作才能完成安装。<br><strong>COPYING 文件:</strong><br>是包含一些版权信息，例如 GNU许可证，一般都是从官方分发的许可证中复制过来。<br>大致就是告诉你开发者拥有哪些版权，你能否修改源代码，能否重新分发，受到哪些限制等<br><strong>ChangeLog 文件:</strong><br>是告诉你更新了哪些功能，添加了什么新功能，以及一些存在问题并指导你如何处理。</p>
<p><strong>注意: 在有些软件源码包中，以上这些文件不一定会同时出现。</strong></p>
<p>另外，<br><strong>Makefile 文件:</strong><br>它只是一个文本文件，其内容包含一些规则，在编译的过程中会读取该文件<br>并安装其中的规则进行编译。其中的内容不过是告诉编译要先编译哪个目录下的文件，<br>再进入哪个目录进行编译，和 要生成哪些名字的文件以及被存放的位置等信息。<br>最后，它有时候还会自动清除编译成功后存在的一些缓存文件。<br><strong>configure 文件:</strong><br>严格来说，它是一个运行脚本(即可被运行的一个文件)，同时它也是一个文本文件。<br>它可以自动设定源程序以符合各种不同平台上 Linux/Unix 系统的特性，<br>并且根据系统参数及环境产生合适的 Makefile 文件或 C 头文件，<br>让源程序可很方便的在这些不同的平台上被编译和链接<br>因此运行这个文件的最终结果会得到以上提到的 Makefile 文件。<br>我们知道，configure 是一个配置文件，但其主要的用途是:<br><strong>1. 根据软件需要，进行软件安装前的一些安装环境配置。</strong><br><strong>2. 配置软件的主要目的为了适应多平台。</strong><br><strong>3. 指引安装后的文件都被存放于系统哪个位置。</strong><br><strong>4. 生成 Makefile 文件以提供编译器编译软件。</strong></p>
<p><strong>make 工具:</strong><br>这是一个 GNU 工具，它只认识 Makefile 文件(有时候可能并非这个名字，除非在选项中指出)<br>它包含一个命令 <code>make</code>，其命令格式为 <code>make [选项] [文件名]</code><br>这个工具的作用是:<br><strong>除非你用选项指定文件的名字，否则该命令会在当前目录下寻找 Makefile 名字的文件，</strong><br><strong>根据文件的指定的规则，并按规则进行编译整个源码目录。</strong><br><strong>在没有意外的情况下，会成功生成一个最终可执行的文件</strong><br>/<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>/<br><strong>install 工具:</strong><br>顾名思义，就是安装的意思。其实际操作是复制文件到指定的目录并设置属性。<br>这些属性包括例如添加环境变量，设置可执行文件等其他文件的一些权限设置等等。<br>它包含一个命令 <code>install</code> 其命令格式为 <code>install  [选项]  ...</code> 可进行多选项<br>/<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>*</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>/</p>
<p>有了以上这些知识我们来尝试编译和安装一个软件<br>以 gedit 软件为例，你可到官方[下载][] gedit-3.22.0.tar.xz<br>解压到 home 下得到 gedit-3.22.0 名字的目录，你可先浏览一遍目录，<br>我假设你已经看过 INSTALL 文件(因为不同版本的安装方法可能有所差异)，<br>安装上一章的安装过程: <strong>配置(configure) -&gt; 编译(make) -&gt; 安装(make install)</strong><br>接着执行以下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#	cd gedit-3.22.0	// 进入源码根目录</span><br><span class="line">#	./configure	// 运行脚本，进行安装前的系统配置</span><br><span class="line">#	make	// 编译</span><br><span class="line">#	su root	// 更改为 root 用户，因为 make install 需要有足够的权限</span><br><span class="line">$	make install	// 编译并安装</span><br></pre></td></tr></table></figure></p>
<p>这里主要解释最后三条命令 ，<br>执行 <code>#    ./configure</code>时:<br>它对软件进行配置，并生成最终文件 Makefile 文件。<br>如果这里配置失败，则不会生成 Makefile 文件。<br>执行 <code>#    make</code> 时:<br>它在当前目录下寻找 Makefile 文件，<br>如果上面配置失败则找不到这个文件编译失败<br>如果你略懂 Makefile 的一些规则语法，当你打开这个文件来看就能发现<br>里面有几个几个隐式规则，其中一个就是名为 <code>install</code> 的规则<br>实际上 <code>$    make install</code>就是执行 Makefile 文件中的隐式规则。<br>该规则定义了一系列安装(拷贝)配置等信息。切勿以为是 make 的选项。<br>此外还有几个隐式规则名为: <code>unistall</code>、<code>clean</code>、<code>disclean</code> 等。<br>这意味着你可以卸载，或在安装过程中出现问题可以清除某些缓存文件等。<br>然而在根目录下有一个 install.sh，根据内容说明，好像是当Makefile<br>文件中没有定义 <code>install</code> 隐式规则时，则执行该 bash 脚本进行安装。</p>
<p>ok！那么在默认情况下，你所安装的软件最终会被分配到这几个目录下:<br><strong>可执行文件在</strong>    <em>/usr/local/bin</em><br><strong>库文件默认在</strong>    <em>/usr/local/lib</em><br><strong>配置文件是在</strong>    <em>/usr/local/etc</em><br><strong>其他资源原件</strong>    <em>/usr/local/share</em></p>
<p>有时候为了便于集中管理某个软件中的各个文件，<br>或者，为了根据自己的需求来配置软件，便有了配置选项。<br>我们知道，<code># ./configure</code>是运行当前目录下的 configure 配置文件。<br>当你使用选项进行配置的时候是这样 <code># ./configure [选项]=你要设置的东西</code>。<br>配置选项很多，但我不会在这里一一列出来。<br>只是 <code>./configure -help</code>可以查看所有可使用的选项和说明 。<br>于是我只在这里介绍一两个常用的选项。<br><strong>-prefix</strong> 选项<br>该选项用于配置安装后的文件目录分布。<br>如果你在安装前这样配置:<br><code># ./configure -prefix=/usr/</code><br>则软件安装后的所有文件都在 /usr/目录下。<br>这样你就能够很好的管理软件包的各个文件，<br>删除也可直接删除整个软件目录而不残留。</p>
<p>段落结语:<br>有时候源码安装软件就是这么简单，<br>但有时候还是很麻烦很复杂，<br>甚至还有可能需要手动修改源码才能成功安装。<br>但但部分软件遵循以上散步可以完成安装。<br>[下载]:(<a href="http://ftp.gnome.org/pub/GNOME/sources/gedit/3.22/" target="_blank" rel="noopener">http://ftp.gnome.org/pub/GNOME/sources/gedit/3.22/</a>)</p>
<h2 id="2-PKGBUILD-文件"><a href="#2-PKGBUILD-文件" class="headerlink" title="2. PKGBUILD 文件"></a>2. PKGBUILD 文件</h2><p>使用 PKGBUILD 的好处是易于修改、可定制(即按自己需求来安装)，<br>从源码下载到成功安装的整个过程都是透明的，使别人无法添加恶意脚本。<br>上一章中我们说到，PKGBUILD 分为三部分，这么说其实不全对，但也不为过。<br>实际上 PKGBUILD 是一个简单的 bash 脚本文件，为文本格式，<br>包含对编译，打包过程的指示，和源代码的下载地址等。<br>该文件的内容其实就是定义一系列变量，和几个函数。<br>变量:<br>理论上(是我个人认为的)，变量名应该可随意改，它被读取的机制应该是按顺序读取。<br>可能是为了让读者容易看，并且格式统一，因此大都采用相同的变量名。<br>我将用这些标准的变量名来讲，以下是标准的 PKGBUILD 个文件的内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// 基本信息</span><br><span class="line">pkgname=软件名</span><br><span class="line">pkgver=软件包版本号</span><br><span class="line">pkgrel=软件版本号</span><br><span class="line">pkgdesc=&quot;软件简介&quot;</span><br><span class="line">arch=(&apos;i686&apos; &apos;x86_64&apos;) // 软件构架，即 32 位还是 64 位</span><br><span class="line">url=&quot;软件下载地址&quot;</span><br><span class="line">license=(&apos;软件包协议，如 GNU 的 GPL 协议&apos;)</span><br><span class="line">depends=(&apos;软件运行的&apos; &apos;依赖&apos;)</span><br><span class="line">optdepends=(&apos;软件的&apos; &apos;可选依赖&apos;)</span><br><span class="line">makedepends=(&apos;软件编译时&apos;  &apos;需要的依赖&apos;)</span><br><span class="line">source=（&quot;编译需要&quot; &quot;的源码&quot;）</span><br><span class="line">md5sums=(&quot;验证源码的完整性&quot;)</span><br><span class="line">// 编译部分，build 是一个函数</span><br><span class="line">build()</span><br><span class="line">&#123;</span><br><span class="line">编译操作</span><br><span class="line">&#125;</span><br><span class="line">// 打包部分，package 是一个函数</span><br><span class="line">package()</span><br><span class="line">&#123;</span><br><span class="line">打包操作</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这两个函数内都是简单的 shell 命令。<br>换句话说，你用源代码是如何编译和打包的的，就把命令添加在编译部分，和打包部分中。<br>当然，这里还有个元数据的问题，和密匙的问题。<br>这是当你要自己写 PKGBUILD 文件是必须理解的两个东西。<br>关于 PKGBUILD 可以参考这两个模板 <a href="(https://aur.archlinux.org/cgit/aur.git/tree/PKGBUILD?h=dgedit-git)">dgedit-git.git</a> 和 <a href="(https://git.archlinux.org/svntogit/community.git/tree/trunk/PKGBUILD?h=packages/ncmpcpp)">ncmpcpp</a></p>
<h2 id="3-makepkg"><a href="#3-makepkg" class="headerlink" title="3. makepkg"></a>3. makepkg</h2><p><strong>配置</strong><br>可通过命令 <code># man makepkg.conf</code>来查询其详细的配置选项<br>makepkg 的主配置文件位于 /etc/makepkg.conf<br>用户自己的配置文件则会位于~/.makepkg.conf<br>建议用户在编译软件包之前检查该配置文件。</p>
<p>该配置文件中的内容选项<br>。。。</p>
<p><strong>打包人信息</strong><br>每个软件包都会有元数据信息，其中一箱就是打包人信息( packager)。<br>默认情况下，用户自己打包的软件标记为 Unknown Packager。<br>如果你要与他人共享自己的软件包，最好还是是提供真实的信息，<br>这可以在 makepkg.conf 文件中的 PACKAGER 变量来设置打包人的信息。</p>
<p>参考地址:<br><a href="https://wiki.archlinux.org/index.php/Makepkg" target="_blank" rel="noopener">https://wiki.archlinux.org/index.php/Makepkg</a><br><a href="https://wiki.archlinux.org/index.php/Creating_packages" target="_blank" rel="noopener">https://wiki.archlinux.org/index.php/Creating_packages</a></p>
<p><strong>非常抱歉，这一部分总结起来非常麻烦，涉及的太多。</strong><br><strong>一些方面还不是很懂，待我有空仔细研究一番再更新本文章。</strong></p>
<h2 id="4-pacman"><a href="#4-pacman" class="headerlink" title="4. pacman"></a>4. pacman</h2><p>以下这些是官方的内容，被我缩小并终结，但没有完全记录下来<br><strong>安装或升级单个软件包</strong><br><code>pacman -S name1, name2...</code><br><strong>指定 extra 库的软件安装</strong><br><code>pacman -S extra/name</code><br><strong>安装包组即包的内容包含其他东西</strong><br><code>pacman -S name</code><br><strong>选择序号安装</strong><br><code>Enter a selection (default=all): 1-10 15</code> 选中 1到10 和 15 的软件包<br><code>Enter a selection (default=all): ^5-8 ^2</code>  除了 5-8 和 2 的软件包<br><strong>查看哪些包属于包组</strong><br><code>pacman -Sg name</code><br><strong>删除软件包，保留其全部已经安装的依赖关系</strong><br><code>pacman -R name</code><br><strong>删除软件包，包括其所有没有被其他已经安装软件包使用的依赖关系</strong><br><code>pacman -Rs name</code><br><strong>删除软件包和所有依赖这个软件包的程序</strong><br><strong>注意，此操作是递归的，可能会删除大量的软件包</strong><br><code>pacan -Rsc name</code><br><strong>删除软件包，但是不删除依赖这个软件包的其他程序</strong><br><code>pacman -Rdd name</code><br><strong>删除某些程序时禁止备份重要的配置文件</strong><br><code>pacman -Rn name</code><br><strong>同步软件仓库，并升级整个系统</strong><br><code>pacman -Syu</code><br><strong>查询本地软件包数据库</strong><br><code>pacman -Q -help</code><br><strong>查询远程同步的数据库</strong><br><code>pacman -S -help</code><br><strong>在包数据库中查询软件包，查询条件包含软件包名和描述</strong><br><code>pacman -Ss name1, name2</code><br><strong>查询已经安装的软件包</strong><br><code>pacman -Qs name1, name2</code><br><strong>显示软件包的详细信息</strong><br><code>pacman -Si name</code><br><strong>查询本地安装包的详细信息</strong><br><code>pacman -Qi name</code><br><strong>获取已经安装的软件包所包含的文件列表</strong><br><code>pacman -Ql name</code><br><strong>检查软件安装包的文件是否存在</strong><br><code>pacman -Qk name</code><br><strong>如果要彻底检查</strong><br><code>pacman -Qkk name</code><br><strong>查询数据库获取某个文件属于哪个软件包</strong><br><code>pacman -Qo /path/name</code><br><strong>列出所有不再作为依赖的软件包（孤立包）</strong><br><code>pacman -Qdt</code><br><strong>列出所有明确被安装，而且不被其他包依赖的软件包</strong><br><code>pacman -Qet</code><br><strong>显示软件包的依赖树</strong><br><code>pactree name</code><br><strong>检查一个安装的软件包被哪些包所依赖</strong><br><code>pactree -r name</code><br>pacman 将下载的软件包保存在 <strong>/var/cache/pacman/pkg/</strong> 下，<br>并且不会移除旧的未安装版本的软件包，只保留软件包的当前有效版本，<br>以下命令可清除未安装的软件包缓存。<br><code>pacman -Sc</code><br><strong>如果要清理所有缓存，但在重装软件包的时候只能重新下载了</strong><br><code>pacman -Scc</code><br><strong>删除近3个版本前的软件包</strong><br><strong>自定义保留最近几个版本</strong><br><code>paccache -rk 2</code><br><strong>三处所有未安装的软件包缓存文件</strong><br><code>paccache -ruk0</code><br><strong>升级系统时安装其他软件包</strong><br><code>pacman -Syu name1, name2 ...</code><br><strong>下载包而不安装</strong><br><code>pacman -Sw name</code><br><strong>安装一个本地包，不从源里下载</strong><br><code>pacman -U /path/name.pkg.tar.xz</code><br><strong>将本地包保持到缓存</strong><br><code>pacman -U file://path/name.pkg.tar.xz</code><br><strong>安装一个远程包，不在 怕充满配置的源里面</strong><br><code>pacman -U http://www......</code><br><code>paccache -r</code><br><strong>查询一个包含具体文件的包名</strong><br><code>pacman -Fy</code><br><strong>查询某个文件的包名</strong><br><code>pacman -Fs pacman</code></p>
<p><strong>配置</strong><br>pacman 的配置文件位于 <strong>/etc/pacman.conf</strong><br>取消文件中的 <strong>VerbosePkglists</strong> 注释，可以在升级前对比新旧版本区别<br><strong>色彩输出</strong><br>取消注释 Color 行<br><strong>不升级软件包</strong><br>加入内容，<code>IgnorePkg = name1 name2 name3 ...</code>,<br>这些被忽略的可通过 <code>pacman -S</code> 升级<br><strong>不升级软件包组，同样也可以不升级单个软件包</strong><br>加入内容 <strong>IgnoreGroup= name1, name2, name3 …</strong></p>
<p><strong>软件仓库</strong><br>除了特殊的 <strong>options</strong> ，<br>每个 pacman.conf 中的 <strong>section</strong> 都定义了一个使用的软件包库，<br>仓库区分为官方和非官方两类，每个仓库都可以直接指定镜像列表。</p>
<p>pacman 数据库通常位于 <strong>/var/lib/pacman/sync</strong> ，<br>这里和 <strong>/etc/pacman.conf</strong> 总开启的软件仓库是一致的。<br>每个 tar.gz 文件都包含一个仓库的软件包</p>
</div><iframe src="/donate/?AliPayQR=/img/alipay.jpg&amp;WeChatQR=/img/wechat.jpg&amp;GitHub=null&amp;BTCQR=null&amp;BTCKEY=null&amp;PayPal=null" style="overflow-x:hidden; overflow-y:hidden; border:0xp none #fff; min-height:240px; width:100%;" frameborder="0" scrolling="no"></iframe><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a class="article-share-link" data-url="http://www.ostensir.org/2017/06/09/包管理机制-2-Arch/" data-id="cjnn5im58000zvrljxt4m9xeg" data-qrcode="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMYAAADGCAAAAACs8KCBAAACJklEQVR42u3aQW7DMAxEUd//0s62RWB7ZigHEPm1KgLH4stCpUgeh7zOr6U///cT91uLFwwYMLZlnLfrPiw3uCuYsu/DTwkDBowBjKvt9ePSBd9/rscGAwYMGFfP6NvrRy0MGDBg/IahH7WVqy8MGDBmMpRLrBLufRKpP/PiXRwGDBgbMvSr6e//fqW/AQMGjK0Yp7n0b2UFtTNaMGDA6M3IxiDcsO5DXDXMAQMGjK4Mt9yftS0rxTUJBgMGjGGMt9sA+uCFUfKDAQNGa4abCLoF/Sz0rNkJAwaMrgy3Hai8VC/3u6MYl3vBgAFjDMMtpWUdRuVgtdNBGDBgDGBkDQB92sHISeVI/sUDAwaM1owsFJ1RCkhIOmHAgDGB4R6CqxqfWaHtYSAMBgwYrRluySwbOa00HoxhCxgwYLRjVJLCymGtUO3SGwwYMAYwjEL80jELfRTsWBsEDBgwNmFkbYBswMJNGY02KgwYMFoz9M2Uw7fe8sxKdTBgwJjD0FM6PTXUQ1cO64e9YMCAMYzhXjj15oH7ExhlPhgwYAxguMdl5Rnjaqq/HwYMGE0Zp7n0MYjKBdgt5MGAAaM3440hCTfVyw7lbNQDBgwY+zLcsTCXser9dj8WBgwY7RhZub8+JOH+B3jIc2HAgAFDHpVY26o8XB8MGDDGM8ID0Wwh2I1MGDBgDGBkx6h+iVWSSOXNYSMTBgwYmzOyvKvSYlzVVIABA8YAxgdjdAPxP3cJ7gAAAABJRU5ErkJggg==">分享</a><div class="tags"></div><div class="post-nav"><a class="pre" href="/2017/06/18/const-C++/">C++指针与常量</a><a class="next" href="/2017/06/07/MarkDown-语法/">MarkDown 语法</a></div><div id="vcomment"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script><script>var notify = 'true' == true ? true : false;
var verify = 'false' == true ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;
window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'GHxGLiMoBO3IDgY1EGD6NxiO-gzGzoHsz',
  appKey:'oMcwvA8ALFdfu8OdGKvUTX0H',
  placeholder:'请输入用户名然后开始评论，为了便于与你联系请添加你的邮箱',
  avatar:'mm',
  guest_info:guest_info,
  pageSize:'10'
})</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"><div id="local-search-result"></div></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/C/">C++</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java-系列/">Java 系列</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Markdown-系列/">Markdown 系列</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/hexo/">hexo</a><span class="category-list-count">3</span></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">Osten Sir.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/search.js?v=0.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>